{"meta":{"title":"Residual Night","subtitle":"Enjoy Coding!","description":null,"author":"WPY","url":"http://yoursite.com","root":"/"},"pages":[{"title":"404 Not Found","date":"2019-09-07T06:04:23.999Z","updated":"2019-04-27T09:01:42.919Z","comments":true,"path":"404.html","permalink":"http://yoursite.com/404.html","excerpt":"","text":"很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"Pictures","date":"2020-02-23T14:15:08.324Z","updated":"2020-02-23T14:15:08.311Z","comments":true,"path":"pictures/index.html","permalink":"http://yoursite.com/pictures/index.html","excerpt":"","text":"画廊&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"},{"title":"About","date":"2020-02-23T12:15:22.536Z","updated":"2020-02-23T12:15:22.521Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"一个来自XM的OIer，一个十足的苣蒻。 目前就读于XMFLS初中部，段排前百(太菜了)。 喜欢捣鼓各种东西，但有时候也因此坏了事。 初二，学习语言C++，NOIp提高(可能)水平233333。 兴趣爱好：code、music、games 使用FL Studio、爱玩Overwatch、Fornite、PUBG、彩6和各种独立游戏。 大爱犬走椛。 D.VA也可 信仰之力：ᴀᴠɪᴄɪɪ ғᴏʀᴇᴠᴇʀ ◢ ◤"},{"title":"分类","date":"2019-09-07T06:04:45.300Z","updated":"2019-04-26T15:41:10.100Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"2020冲刺CSP-S<2> P5414[YNOI2019]排序","slug":"2020Dash-2","date":"2020-02-26T14:56:13.000Z","updated":"2020-02-26T15:19:57.375Z","comments":true,"path":"2020/02/2020Dash-2/","link":"","permalink":"http://yoursite.com/2020/02/2020Dash-2/","excerpt":"","text":"Final Dash日常更新 审题传送门 首先要明确，我们的最优解是不可能把同一个数字转换两次的（很好想） 然后，奇怪的思路就来了： 既然我们可以一次把它移到正确的位置上，那么这个数字就可以理解为直接被移走了。 所以…… 做法题目被我们转化成了：删除几个数字，使得数列单调递增，所求的是移走数字的最小和。 使得删除的和最小，就意味着留下的和最大。 那么问题就变成了：保留几个单调递增的数字，使得和最大。 那就简单很多了。 程序代码最长不降子序列变形 F[i]=max(a[i], f[j]+a[i])其中，j&lt;i`a[j]&lt;=a[i]` f[i]表示以a[i]结尾的的不降序列的和的最大值； 初始值：f[i]=a[i] 结果：max(f[i])即最优的序列以任意数结尾都有可能。 int T,n,a[N],f[M];int sum,ans;int main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;T; while(T--)&#123; cin&gt;&gt;n; sum=ans=0; for(int i=1; i&lt;=n; i++)&#123; cin&gt;&gt;a[i]; sum+=a[i]; //计算总和 f[i]=a[i]; //初始化 &#125; for(int i=1; i&lt;=n; i++) for(int k=1; k&lt;i; k++) if(a[i]&gt;=a[k]) f[i]=max(f[i],f[k]+a[i]); //dp求和找最大的上升子序列 for(int i=1; i&lt;=n; i++) ans=max(ans,f[i]); cout&lt;&lt;sum-ans&lt;&lt;endl; //最小代价 &#125; return 0;&#125;","categories":[{"name":"C++学习","slug":"C-学习","permalink":"http://yoursite.com/categories/C-学习/"}],"tags":[{"name":"CSP","slug":"CSP","permalink":"http://yoursite.com/tags/CSP/"},{"name":"奇怪的思路","slug":"奇怪的思路","permalink":"http://yoursite.com/tags/奇怪的思路/"},{"name":"单调队列","slug":"单调队列","permalink":"http://yoursite.com/tags/单调队列/"}]},{"title":"2020冲刺CSP-S<1> P1311选择客栈","slug":"2020Dash-1","date":"2020-02-24T15:17:04.000Z","updated":"2020-02-26T15:13:16.108Z","comments":true,"path":"2020/02/2020Dash-1/","link":"","permalink":"http://yoursite.com/2020/02/2020Dash-1/","excerpt":"Final Dash信竞路上的重要节点","text":"Final Dash信竞路上的重要节点 写在前面 👇 今年的CSP-S就是初中生涯的最后一次竞赛了。初二成绩不理想（110左右，二等），希望初三拿个一等。而且，年段排名也掉到了70，副科炸开。所以，来个Ultra Dash吧。 初审题题目传送门 题目信息整理后如上图，要求求解的是同色调，且最低消费不超过他们支付能力的两两组合数目。 以上信息只要知道客栈编号，相应的色调，最低消费就都清楚了，可能很容易想到暴力搜索。 做法法一：O(n^3)直接进行暴力枚举，用i,j枚举两个人的客栈位置，判断区间是否合法，用ans统计并输出。 预估：过前两个测试点。约20 pts 法二：O(n^2)在算法一大基础上进行优化。我们会发现算法一用了O(n)的时间来判断这个区间是否合法。如果我们做一些预处理，那么就可以节省这一部分的时间。 很快，就想到了前缀和。即从第一家客栈到目前的客栈为止符合消费能力的客栈数。 预估：50 pts 法三O(n*k) 观察数据范围，10^5平方级别的算法会超时。观察到k（颜色）很小，这时应当尽量朝O(n*k)优化算法 ​ 中间有好多位置我需要访问好多遍，能不能一遍完成呢。可以从左往右依次扫过去的过程中记下在i位置之前已经出现了几个颜色一样的了，记为num[i]，然后再保存一下当前最后的一个够便宜的客栈的位置，记为last，每次遇到一个新的当前颜色的客栈，我就给答案加上最后一个够便宜的客栈之前的相同颜色的个数，即就是加上num[last]。 预估：60 pts 法四：O(n)通过观察数据范围，O(n*k)的算法也对于加强版数据会超时，这时就要继续将算法优化至O(n) 可以设置三个数组： SZ1[X]: 色调X到当前客栈有几家 SZ3[X]: 上一次遇到不超过P的时间节点（客栈号） SZ2[X]: 该时间点之前色调与i相同的客栈有几家 ​ 细节：同色数目先统计再累加，所以不会出现自己和自己配对的情况。 加强法四可以过加强版传送门","categories":[{"name":"C++学习","slug":"C-学习","permalink":"http://yoursite.com/categories/C-学习/"}],"tags":[{"name":"CSP","slug":"CSP","permalink":"http://yoursite.com/tags/CSP/"},{"name":"奇怪的思路","slug":"奇怪的思路","permalink":"http://yoursite.com/tags/奇怪的思路/"}]},{"title":"<蔚蓝Celeste>失败和抑郁","slug":"Celeste","date":"2019-11-03T04:45:01.000Z","updated":"2019-11-03T07:50:22.764Z","comments":true,"path":"2019/11/Celeste/","link":"","permalink":"http://yoursite.com/2019/11/Celeste/","excerpt":"为什么要登山？ 因为山就在那里。 【游戏推荐】1.蔚蓝Celeste","text":"为什么要登山？ 因为山就在那里。 【游戏推荐】1.蔚蓝Celeste 前言&lt;蔚蓝山脉(Celeste)&gt;是一款由加拿大电子游戏设计师马特·索尔森（Matt Thorson）和诺尔·贝瑞（Noel Berry）所设计开发的平台类电子游戏。这个游戏最初是在一个为期四天的游戏设计比赛中设计出的原型作品，之后扩充成为了完整的版本。这款游戏在2018年1月在Microsoft Windows，任天堂Switch、PlayStation 4、Xbox One、MacOS和Linux平台上发行。 《蔚蓝》发行后随即获得大量好评，主要集中在其剧情和配乐方面。IGN给予该作10/10分，成为了2018年首款获得该分数的游戏。 聆听美妙的BGM：网易云音乐上的 &lt;蔚蓝&gt;原声带 玩了十几小时，前来推荐。 游戏内容虽然是一部看似简单的像素风游戏，但是却能把手残党虐得扎心。如你所见，整个游戏的目的就是登上蔚蓝山顶（新出的第九章跑到了太空）。不过，再次之前，你将遭遇到各种重重困难。 剧情在这个横版跳跃游戏中，存有一些感人的剧情是挺难能可贵的，每一章节的游戏机制、BOSS战，基本都会和剧情相挂钩。剧情的推进则是通过对话的方式进行。 操作 根据本人肝了近15小时的游戏，达到了第四章结束。 但是，有一点极其重要。最好不要用键盘玩耍这个游戏，因为你会不自觉地砸起键盘键盘的手感没有手柄好，玩久了会手酸。这也促发了我买个手柄的想法能否实现就看情况了2333。 主角有左右位移和下蹲，方向键&lt;上&gt;只是作为引导方向使用。此外还有冲刺、抓墙、小跳这三种技能，较好操控，玩法多样。玩家们也自己研究出不少的跳跃、速通技巧。 关卡设计每个章节都会引入一些特殊的新机制。比如跳板，狂风，平移机械块，蓝色泡泡球等等，这些机制都让这个游戏的可玩性变得更高。 其次，在首页的选择章节的设计也是让我觉得非常awesome(运用自如 一个微缩的Celeste山模型，上面简略的内容都有在游戏内实现，比如右侧的缆车。在这里你可以看到各种统计： 玩的比较菜，别喷 另外，每一章有若干草莓、一张B面磁带和一颗蓝心，内容丰富。如果你想全收集的话，你将经历过死亡次数的洗礼和寻找的乐趣。千万不要查看攻略！第二章节的蓝心收集就挺有趣的，一张椅子上的旧书预示着一切。如果你是普通玩家，建议你收集草莓。 还有，游戏打开后的小图标就是一个像素草莓。 小小吐槽我丶太丶难丶了！ 如果你先游戏的正常章节（A面）不够难，还可以在其中收藏磁带（B面）然后进行挑战，然后在C面玩耍。 此外，你可以尝试全收集。还有一命通关（是人？）的金草莓等着你。 还不够，我求求你去速通ba。 其他真的没有什么好吐槽的了，就是一定要有耐心，不然你会体验到几天换一个键盘/手柄的奇妙生活。 体验手感不错。 如果在某处卡住没有耐心，可以打开游戏的帮助模式（挂b），进行章节跳跃或是调低倍数、无敌等，让一部分的玩家有游戏体验。 每一章都是由简单到困难，开篇部分会引出新的机制，让你做热身。 总结总的来说，这部作品的蕴意也很深。它甚至公开探讨了抑郁症这一话题：主人公与黑化的自己（内心）进行争斗，并取得胜利登上巅峰的故事让人感触极深。但你要是想要完成情节，要有自己的技术才行（或者打开游戏的内置挂）。 在我心中，它也是一部满分的作品，你可以在其中体验到失败豁达和成功的乐趣，然后大胆面对生活，寓意不错。 用来装B秀技术也是不错的选择。 另，别在做复习、工作等要紧之事时玩，耗时一看我就是亲身经历233333 在STEAM上花了34买的，原价68。如果你真的想玩或是真的欣赏游戏这一门第九艺术，那么我个人认为这68元还是很值的。 结语看大佬视频猛如虎，自己操作像条狗 带上自己的一份热血与坚持，登上心中的那一座山 STEAM 链接","categories":[{"name":"游戏","slug":"游戏","permalink":"http://yoursite.com/categories/游戏/"}],"tags":[{"name":"单机游戏","slug":"单机游戏","permalink":"http://yoursite.com/tags/单机游戏/"}]},{"title":"CSP-S第二轮tips","slug":"2019CSP-S复赛tips","date":"2019-10-01T14:45:01.000Z","updated":"2019-11-11T15:10:15.118Z","comments":true,"path":"2019/10/2019CSP-S复赛tips/","link":"","permalink":"http://yoursite.com/2019/10/2019CSP-S复赛tips/","excerpt":"一些极其重要的提丶高丶组算法。","text":"一些极其重要的提丶高丶组算法。 二分P1577 const int N=100000+1000;int n,p,d[N],l=1,r=99999999;inline bool pand(int x)&#123; int sans=0; for(int i=1; i&lt;=n; i++) sans+=d[i]/x; return sans&gt;=p;&#125;int main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;n&gt;&gt;p; for(int i=1; i&lt;=n; i++)&#123; double a; cin&gt;&gt;a; d[i]=int(a*100); //化成整数做 &#125; while(l&lt;=r)&#123; int mid=(l+r)&gt;&gt;1; if(pand(mid)) l=mid+1; else r=mid-1; &#125; return cout&lt;&lt;fixed&lt;&lt;setprecision(2)&lt;&lt;double(r/100.0)&lt;&lt;endl,0; //还原&#125; 快速幂P1226 #include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longll b,q,k,ans=1;inline ll kasm()&#123; while(q&gt;0)&#123; if(q &amp; 1 ==1) ans=ans*b%k; //不要忘记% b=b*b%k; q &gt;&gt;= 1; &#125; return ans;&#125;int main()&#123; cin&gt;&gt;b&gt;&gt;q&gt;&gt;k; return cout&lt;&lt;b&lt;&lt;\"^\"&lt;&lt;q&lt;&lt;\" mod \"&lt;&lt;k&lt;&lt;\"=\"&lt;&lt;kasm()%k&lt;&lt;endl,0;&#125; 搜索深搜###P2919 int n,m,a[1000][1000]=&#123;0&#125;,b[1000][1000]=&#123;0&#125;,ans=0,flag,maxx;int dx[]=&#123;0,-1,-1,-1,0,0,1,1,1&#125;,dy[]=&#123;0,-1,0,1,-1,1,-1,0,1&#125;; //方向数组void dfs(int x,int y)&#123; for(int i=1; i&lt;=8; i++) &#123; int xx=x+dx[i],yy=y+dy[i]; if(xx&gt;0 &amp;&amp; xx&lt;=n &amp;&amp; yy&gt;0 &amp;&amp; yy&lt;=m) &#123; if(a[x][y]==maxx &amp;&amp; a[xx][yy]&gt;maxx) &#123;flag=0; continue;&#125; if(!b[xx][yy] &amp;&amp; a[xx][yy]&lt;=a[x][y]) &#123; b[xx][yy]=1; dfs(xx,yy); &#125; &#125; &#125;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; for(int i=1; i&lt;=n; i++) for(int k=1; k&lt;=m; k++) cin&gt;&gt;a[i][k]; for(int i=1; i&lt;=n; i++) for(int k=1; k&lt;=m; k++) &#123; if(a[i][k] &amp;&amp; !b[i][k]) &#123; flag=1; maxx=a[i][k]; dfs(i,k); ans+=flag; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; ###P1506 const int N=500+1000;int n,m,mp[N][N],ans=0;int dx[]=&#123;0,1,-1,0,0&#125;,dy[]=&#123;0,0,0,1,-1&#125;;void dfs(int x,int y)&#123; mp[x][y]=1; for(int i=1; i&lt;=4; i++)&#123; int x0=x+dx[i],y0=y+dy[i]; if(x0&gt;0 &amp;&amp; x&lt;=n &amp;&amp; y0&gt;0 &amp;&amp; y0&lt;=m &amp;&amp; !mp[x0][y0]) //判断边界和障碍物 dfs(x0,y0); &#125;&#125;int main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;n&gt;&gt;m; for(int i=1; i&lt;=n; i++) for(int k=1; k&lt;=m; k++)&#123; char a; cin&gt;&gt;a; if(a=='*') mp[i][k]=1; &#125; for(int i=1; i&lt;=n; i++)&#123; //边缘1 if(!mp[i][1]) dfs(i,1); if(!mp[i][m]) dfs(i,m); &#125; for(int i=1; i&lt;=m; i++)&#123; //边缘2 if(!mp[1][i]) dfs(1,i); if(!mp[n][i]) dfs(n,i); &#125; for(int i=1; i&lt;=n; i++) //统计未被淹没的地方 for(int k=1; k&lt;=m; k++) if(!mp[i][k]) ans++; return cout&lt;&lt;ans&lt;&lt;endl,0;&#125; 种子染色P1451 int m,n,a[200][200],ans=0;int dx[4]=&#123;-1,0,1,0&#125;,dy[4]=&#123;0,-1,0,1&#125;;void print()&#123; for(int i=0; i&lt;m; i++) &#123; for(int k=0; k&lt;n; k++) cout&lt;&lt;a[i][k]; cout&lt;&lt;endl; &#125; cout&lt;&lt;ans&lt;&lt;endl;&#125;void dfs(int x,int y)&#123; if(x&gt;m || x&lt;0 || y&gt;n || y&lt;0) return; a[x][y]=0; for(int i=0; i&lt;4; i++) &#123; int x2=x+dx[i],y2=y+dy[i]; if(a[x2][y2]) dfs(x2,y2); &#125;&#125;int main()&#123; cin&gt;&gt;m&gt;&gt;n; for(int i=0; i&lt;m; i++) for(int k=0; k&lt;n; k++) &#123; char c; cin&gt;&gt;c; a[i][k]=c-'0'; &#125; for(int i=0; i&lt;m; i++) for(int k=0; k&lt;n; k++) if(a[i][k]) ans++,dfs(i,k); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; 记忆化搜索P1434 const int N=100+500;int n,m,mp[N][N],f[N][N],ans=-99;int dx[]=&#123;0,1,-1,0,0&#125;,dy[]=&#123;0,0,0,-1,1&#125;;inline int dfs(int x,int y)&#123; if(f[x][y]) return f[x][y]; int sans=1; for(int i=1; i&lt;=4; i++)&#123; int tx=x+dx[i],ty=y+dy[i]; if(tx&gt;0 &amp;&amp; tx&lt;=n &amp;&amp; ty&gt;0 &amp;&amp; ty&lt;=m &amp;&amp; mp[x][y]&gt;mp[tx][ty]) sans=max(sans,dfs(tx,ty)+1); &#125; f[x][y]=sans; //记忆化 return sans;&#125;int main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;n&gt;&gt;m; for(int i=1; i&lt;=n; i++) for(int k=1; k&lt;=m; k++) cin&gt;&gt;mp[i][k]; for(int i=1; i&lt;=n; i++) for(int k=1; k&lt;=m; k++)&#123; f[i][k]=dfs(i,k); ans=max(ans,f[i][k]); &#125; return cout&lt;&lt;ans&lt;&lt;endl,0;&#125; 动归最长不降子序列P1481 strstr(s1,s2)判断s2是否s1的子串，没有找到返回NULL，找到则返回子串第一个字符的地址 const int N=2000+100;int n,f[N],ans=-999;char s[N][N];int main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;n; for(int i=1; i&lt;=n; i++)&#123; cin&gt;&gt;s[i]; f[i]=1; //初始化 for(int k=i-1; k&gt;=1; k--) if(strstr(s[i],s[k])==s[i]) f[i]=max(f[k]+1,f[i]); //DP ans=max(ans,f[i]); //更新 &#125; return cout&lt;&lt;ans&lt;&lt;endl,0;&#125; 最长上升子序列(LIS)例子： 有6个数，分别是： 1 7 6 2 3 4求最长上升子序列。 最长上升子序列的元素不一定相邻 最长上升子序列一定是原序列的子集 所以这个例子中的LIS就是：1 2 3 4，共4个$$n^2$$ void print(int x)&#123; if(!x) return; print(from[x]); cout&lt;&lt;a[x]&lt;&lt;endl; //迭代输出&#125;int main()&#123; cin&gt;&gt;n; for(int i=1; i&lt;=n; i++) cin&gt;&gt;a[i]; for(int i=1; i&lt;=n; i++)&#123; dp[i]=1; from[i]=0; //from:前驱记录 for(int k=1; k&lt;i; k++) if(a[k]&lt;d[i] &amp;&amp; dp[i]&lt;dp[k]+1) dp[i]=dp[k]+1,from[i]=k; &#125; int ans=dp[1],p=1; for(int i=1; i&lt;=n ;i++) if(ans&lt;dp[i]) ans=dp[i],p=i; cout&lt;&lt;ans&lt;&lt;endl; print(p);&#125; 最长公共子序列(LCS)P1439 使用dp[i][j]表示第一个串的前i位，第二个串的前j位的LCS长度 则状态转移方程为： 1: 如果有新的公共元素(A1[i]==A2[j])$$dp[i][j]=max(dp[i][j],dp[i-1][j-1]+1);$$2: 如果无法更新公共元素$$dp[i][j]=max(dp[i-1][j],dp[i][j-1]);$$ 朴实做法 (n^2)cin&gt;&gt;n&gt;&gt;m;for(int i=1; i&lt;=n; i++) cin&gt;&gt;a1[i];for(int i=1; i&lt;=m; i++) cin&gt;&gt;a2[i];for(int i=1; i&lt;=n; i++) for(int k=1; k&lt;=m; k++)&#123; dp[i][k]=max(dp[i-1][k],dp[i][k-1]); if(a1[i]==a2[k]) dp[i][k]=max(dp[i][k],dp[i-1][k-1]+1); &#125;return cout&lt;&lt;dp[n][m]&lt;&lt;endl,0; 实则爆零 AC 以第一个串为标准，用第二个串来匹配第一个串，看能匹配多少 把第一个串离散化后的数组是满足上升，反过来，满足上升的也就是满足原串的排列顺序的 求一个最长不下降序列 lower_bound(begin,end,num)：从数组的begin位置到end-1位置二分查找第一个大于或等于num的数字，找到返回该数字的地址，不存在则返回end。 通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。 #define INF 0x7fffffffconst int N=100000+1000;int a[N],b[N],ma[N],ans=0,f[N],p[N],n;int main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;n; for(int i=1; i&lt;=n; i++)&#123; cin&gt;&gt;a[i]; ma[a[i]]=i; &#125; for(int i=1; i&lt;=n; i++) cin&gt;&gt;b[i]; for(int i=1; i&lt;=n; i++)&#123; if(ma[b[i]]&gt;p[ans])&#123; p[++ans]=ma[b[i]]; f[i]=ans; continue; &#125; int k=lower_bound(p+1,p+ans+1,ma[b[i]])-p; p[k]=ma[b[i]]; f[i]=k; &#125; return cout&lt;&lt;ans&lt;&lt;endl,0;&#125; 01背包P1417 平常做01背包的题时，由于i的价值永远是不变的，所以i讨论的顺序对结果不影响 但是这道题中，如果你先讨论了1号点，再讨论第二点，第二点的价值会减小，反之一号点会减小，这两个哪个更优是不确定的，所以如果你先讨论1号点就会错 由此，需要按优先度对所有点进行排序 const int N=100000+1000;#define ll long longstruct data&#123; ll a,b,c;&#125;d[N];ll T,n,f[N],ans=0;inline bool cmp(data x,data y)&#123;return x.c*y.b&lt;y.c*x.b;&#125;int main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;T&gt;&gt;n; for(ll i=1; i&lt;=n; i++) cin&gt;&gt;d[i].a; for(ll i=1; i&lt;=n; i++) cin&gt;&gt;d[i].b; for(ll i=1; i&lt;=n; i++) cin&gt;&gt;d[i].c; sort(d+1,d+n+1,cmp); for(ll i=1; i&lt;=n; i++) for(ll k=T; k-d[i].c&gt;=0; k--) f[k]=max(f[k],f[k-d[i].c]+d[i].a-k*d[i].b); for(ll i=1; i&lt;=T; i++) ans=max(ans,f[i]); return cout&lt;&lt;ans&lt;&lt;endl,0;&#125; P1510 用01背包求出当精卫剩下的体力为x时，她最多能填多少海。这样，她第一次能填完海时剩下的体力就是所需的最小体力。 最后添加一个搜索就完成了。 int v,n,c,ans;int f[100000];int main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;v&gt;&gt;n&gt;&gt;c; for(int i=1; i&lt;=n; i++)&#123; int a,b; cin&gt;&gt;a&gt;&gt;b; for(int k=c; k&gt;=b; k--) f[k]=max(f[k],f[k-b]+a); //填或不填 &#125; int p=0; for(int i=1; i&lt;=c; i++) if(f[i]&gt;=v) &#123;p=1; ans=i; break;&#125; if(p) cout&lt;&lt;c-ans&lt;&lt;endl; else cout&lt;&lt;\"Impossible\"&lt;&lt;endl; return 0;&#125; P1855const int N=1000;int n,ma,ta,m[N],t[N],f[N][N];int main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;n&gt;&gt;ma&gt;&gt;ta; for(int i=1; i&lt;=n; i++)&#123; cin&gt;&gt;m[i]&gt;&gt;t[i]; for(int k=ma; k&gt;=m[i]; k--) for(int j=ta; j&gt;=t[i]; j--) f[k][j]=max(f[k][j],f[k-m[i]][j-t[i]]+1); //实现与否 &#125; return cout&lt;&lt;f[ma][ta]&lt;&lt;endl,0;&#125; 完全背包P1616int n,m;int v[100001],t[100001],f[100001]; int main()&#123; cin&gt;&gt;n&gt;&gt;m; for(int i=1; i&lt;=m; i++) cin&gt;&gt;t[i]&gt;&gt;v[i]; for(int i=1; i&lt;=m; i++) for(int k=t[i]; k&lt;=n; k++) f[k]=max(f[k],f[k-t[i]]+v[i]); cout&lt;&lt;f[n]&lt;&lt;endl; return 0;&#125; CSP-S problem plan 1.二分 (洛谷 1577) 2.快速幂 （洛谷 1226） 3.搜索1&gt;.深搜 （洛谷2919）2&gt;.广搜 （洛谷1506）3&gt;.种子染色（洛谷1451）3&gt;.记忆化搜索 （洛谷1434） 4.动规1&gt;.最长不降子序列：14812&gt;.最长公共子序列：14393&gt;.01背包：1417 1510 18554&gt;.完全背包：16165&gt;.多重背包：17766&gt;.区间动规：3146 5.图论1&gt;.最短路dij （堆优化）1629floyed 1364SPFA 1529最短路计数 1144 2&gt;.最小生成树prim：1194克鲁斯卡尔：1195 3&gt; targen强连通分量 1656","categories":[{"name":"C++学习","slug":"C-学习","permalink":"http://yoursite.com/categories/C-学习/"}],"tags":[{"name":"CSP","slug":"CSP","permalink":"http://yoursite.com/tags/CSP/"}]},{"title":"卡特兰数 浅析","slug":"卡特兰数","date":"2019-09-03T14:06:16.000Z","updated":"2019-10-01T14:43:47.853Z","comments":true,"path":"2019/09/卡特兰数/","link":"","permalink":"http://yoursite.com/2019/09/卡特兰数/","excerpt":"卡特兰数又称卡塔兰数 (Catalan Number),是组合数学中一个经常出现在各种计数问题中的数列。其前几项为： 1251442132429143048621679658786208012742900...","text":"卡特兰数又称卡塔兰数 (Catalan Number),是组合数学中一个经常出现在各种计数问题中的数列。其前几项为： 1251442132429143048621679658786208012742900... 公式求卡特兰数列的第n项 公式1$$f(n)=\\sum_{i=0}^{n-1}f(i)\\times f(n-i-1)$$ 公式2$$f(n)=\\frac {f(n-1)\\times(f\\times n-2)}{n+1}$$ 公式3$$f(n)=\\frac{C_{2n}^{n}}{n+1}$$ 公式4$$f(n)=C_{2n}^{n}-C_{2n}^{n-1}$$ 应用卡特兰数经常出现在OI以及ACM中，在生活中也有广泛的应用。 进出栈问题栈是一种先进后出（FILO,First In Last Out）的数据结构 那么一个足够大的栈的进栈序列为1,2,3,⋯,n时有多少个不同的出栈序列？ 假设k为最后一个出栈的元素。比k早进栈且早出栈的有k-1个数，一共有f(k-1)种方案。比k晚进栈且早出栈的有n-k个数，一共有f(n-k)种方案。所以一共有f(k-1)*f(n-k)种方案。当k取不同值时，产生的出栈序列是互相独立的，因此可累加。因为k的取值范围是1~n，所以结果为$$f(n)=f(0)\\times f(n-1)+f(1)\\times f(n-2)+…+f(n-1)\\times f(0)$$注意：n&gt;=2 例题：P1044 栈 long long f[N];f[0]=f[1]=1;cin&gt;&gt;n;for(int i=2; i&lt;=n; i++) for(int k=0; k&lt;i; k++) f[i]+=f[k]*f[i-k+1];cout&lt;&lt;f[n]&lt;&lt;endl; 二叉树的计数已知一颗二叉树有n个结点，问：该二叉树能组成多少种不同的形态? 假设如果采用中序遍历的话，根结点第k个被访问到，则根结点的左子树有k-1个点、根结点的右指数有n-k个点。k的取值范围为1到n。明显的卡特兰数。 AB排列问题有n个A和n个B排成一排，从第1个位置开始到任何位置，B的个数不能超过A的个数，这样的排列有多少种？ 如： n=1: AB n=2: AABB ABAB n=3: AAABBB AABABB AABBAB ABAABB ABABA 在n*n的格子中，只在下三角行走，每次横或竖走一格，有多少种走法？ 向右走相当于进栈(A)，向左走相当于出栈(B)，本质就是n个数出栈次序的问题。 乘法加括号NOI 1988 对于连乘：$$a[0]\\times a[1]\\times a[2]\\times …\\times a[n]$$加了括号后可以改变它的运算顺序，问有多少种不同的运算顺序？ 将其表示成一颗二叉树，把*逐个作为根，得到卡特兰数。 参考文献&amp;网址 &lt;信息学奥赛之数学一本通&gt;林厚从 主编, 东南大学出版社 https://blog.csdn.net/wookaikaiko/article/details/81105031 https://www.luogu.org/blog/Ning-H/solution-p1044","categories":[{"name":"C++学习","slug":"C-学习","permalink":"http://yoursite.com/categories/C-学习/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://yoursite.com/tags/数论/"}]},{"title":"高精度运算","slug":"高精度运算","date":"2019-08-13T04:10:07.000Z","updated":"2019-09-02T14:53:10.850Z","comments":true,"path":"2019/08/高精度运算/","link":"","permalink":"http://yoursite.com/2019/08/高精度运算/","excerpt":"必要的高精度运算。","text":"必要的高精度运算。 高精加int i=1,x=0; memset(c,0,sizeof(c));while(i&lt;=la || i&lt;=lb) //只要i小于a或b的长度就的循环&#123; c[i]+=a[i]+b[i]; //第i位加，注意含进位，给c数组 c[i+1]+=c[i]/10; //取该位置的进位 c[i]%=10; //留下没有进位的部分 i++;&#125;if(c[i]&gt;0) lc=i;else lc=i-1; //lc记录结果的长度 高精减int i=1; memset(c,0,sizeof(c));while(i&lt;=la)&#123; if(a[i]&lt;b[i]) a[i]+=10,a[i+1]--; c[i]=a[i]-b[i]; i++;&#125;lc=i;while(lc&gt;1 &amp;&amp; c[lc]==0) lc--; 高精乘memset(c,0,sizeof(c));for(int i=1; i&lt;=lb; i++)&#123; x=0; for(int k=1; k&lt;=la; k++)&#123; c[i+k-1]+=b[i]*a[k]+x; x=c[i+k-1]/10; c[i+k-1]%=10; &#125; c[i+la]=x;&#125;lc=la+lb;while(c[lc]==0 &amp;&amp; lc&gt;1) lc--; 单精乘高精「n\u0010!」 cin&gt;&gt;n;c[1]=l=1,x=0;for(int i=1; i&lt;=n; i++)&#123; x=0; for(int k=1; k&lt;=l; k++)&#123; c[k]=c[k]*i+x;x=c[j]/10; x=c[j]/10; c[j]%=10; &#125; while(x&gt;0)&#123; l++; c[l]=x%10; x/=10; &#125;&#125;for(int i:=l;i&gt;=1;i--) cout&lt;&lt;c[i]; 高精除单精for(int i=1; i&lt;=la; i++)&#123; c[i]=(x*10+a[i])/b; x=(x*10+a[i])%b;&#125;int p=1;while(c[p]==0 &amp;&amp; p&lt;la) p++;for(int i=p; i&lt;=la; i++) cout&lt;&lt;c[i];//最后的x为余数","categories":[{"name":"C++学习","slug":"C-学习","permalink":"http://yoursite.com/categories/C-学习/"}],"tags":[{"name":"高精","slug":"高精","permalink":"http://yoursite.com/tags/高精/"}]},{"title":"是基础算法！","slug":"基础算法","date":"2019-08-11T02:45:19.000Z","updated":"2019-09-06T13:48:31.818Z","comments":true,"path":"2019/08/基础算法/","link":"","permalink":"http://yoursite.com/2019/08/基础算法/","excerpt":"一些基础的算法。","text":"一些基础的算法。 最大公约数gcd开挂法：__gcd(a,b);STL大法好！！！(震耳欲聋) int gcd(int a,int b)&#123; if(b==0) return a; return gcd(b,a%b);&#125; 最大公约数与最小公倍数的关系gcd(a,b)*lcm(a,b)=ab 素数判断简单法暴力超时见祖宗 bool pand(int x) //x&gt;=3&#123; for(int i=2; i*i&lt;=x; i++) if(x%i==0) return 0; return 1;&#125; 筛法 取最小的素数2，筛去它的所有倍数 取未被筛最小的数（一定是素数），再筛去它的所有倍数 重复直至全部都是素数（取最小数只需到 sqrt(n) ） bool isprime[N]int n,ans=0;int main()&#123; memset(isprime,1,sizeof(isprime)); cin&gt;&gt;n; isprime[1]=0; for(int i=2; i&lt;=sqrt(n); i++) //生成 if(isprime[i]) for(int k=i*i; k&lt;=n; k+=i) isprime[k]=0; for(int i=2; i&lt;=n; i++) //输出 if(isprime[i]) &#123;ans++; cout&lt;&lt;i&lt;&lt;\" \";&#125; cout&lt;&lt;endl&lt;&lt;ans&lt;&lt;endl; return 0;&#125; 排序 选择排序for(int i=1; i&lt;=n-1; i++) for(int j=i+1; j&lt;=n; j++) if(a[i]&gt;a[j]) t=a[j],a[j]=a[i],a[i]=t; 冒泡排序对于接近有序的数列，加标记可以缩短排序时间 for(int i=n-1; i&gt;=1; i--)&#123; int p=0; for(int k=1; k&lt;=i; k++) if(d[k]&gt;d[k+1]) swap(d[k+1],d[k]),p=1; if(!p) break;&#125; 插入排序for(int i=2; i&lt;=n; i++)&#123; int p=a[i]; for(int k=i; k&gt;1 &amp;&amp; p&lt;a[k-1]; k--) a[k]=a[k-1]; a[k]=p;&#125; 快排sort(a+1,a+n+1,cmp);STL大法好！！！(再次破音) //手写快排void sort(int l,int r)&#123; int x=l,y=r,mid=a[(l+r)/2]; //mid:取一个数 do&#123; while(a[i]&lt;mid) x++; //左边起比mid小的数不动，x停在不比mid小的位子 while(mid&lt;a[y]) y--; //右边起比mid大的数不动，y停在不比mid大的位子 if(x&lt;=y) swap(a[x],a[y]),x++,y--; //如果x与y不交叉，交换x与y的数，x与y各再跳一步 &#125;while(x&lt;=y); //直至x与y交叉；mid已经在交叉的位置了 if(l&lt;y) qsort(l,y); //左边还有数(l&lt;y),递归 if(x&lt;r) qsort(x,r); //右边还有数(x&lt;r),递归&#125; 归并排序把两个已经有序的序列，归并成一个有序的序列 归并排序不会像快排那样蜕化为o(n2),最好和最坏的情况都是o(nlog2n) void merge_sort(int l,int r)&#123; if(l!=r)&#123; int mid=(l+r)/2; merge_sort(l,mid); merge_sort(mid+1,r); merge(l,mid,r); &#125;&#125; void merge(int p,int q,int r)&#123; int tt=p,tl=p,tr=q+1; //tt是tmp的指针，tl和tr是两个待合并有序序列的指针 while(tt&lt;=r)&#123; if(tl&lt;=q &amp;&amp; (tr&gt;r || a[tl]&lt;a[tr])) tmp[tt++]=a[tl++]; //tl还有元素，tr已经没有元素或tr指的元素较大 else tmp[tt++]=a[tr++]; //除上述情况的其他情况 &#125; for(int i=p;i&lt;=r;i++) a[i]=tmp[i]; //在tmp[]合并好后要搬到a[]中&#125; 二分a[ ]已经排序 递归算法bool find(int x,int l,int r) //x为要查找的数&#123; if(l&gt;r) return 0; int mid=(l+r)/2; if(x==a[mid]) return 1; if(x&lt;a[mid]) return find(x,l,mid-1); if(x&gt;a[mid]) return find(x,mid+1,r);&#125; 非递归算法bool find(int x,int l,int r)&#123; while(l&lt;=r)&#123; int mid=(l+r)/2; if(x==mid) return 1; if(x&lt;a[mid]) r=mid-1; else l=mid+1; &#125;&#125; 快速幂//输出：ans%pans=1,a%=p;while(b)&#123; if(b%2==1) ans=(ans*a)%p; a=(a*a)%p; b&gt;&gt;1;&#125;cout&lt;&lt;ans&lt;&lt;endl;","categories":[{"name":"C++学习","slug":"C-学习","permalink":"http://yoursite.com/categories/C-学习/"}],"tags":[{"name":"简单算法","slug":"简单算法","permalink":"http://yoursite.com/tags/简单算法/"}]},{"title":"R.I.P. Avicii ◢ ◤","slug":"Avicii","date":"2019-06-06T15:00:00.000Z","updated":"2019-07-18T09:19:55.428Z","comments":true,"path":"2019/06/Avicii/","link":"","permalink":"http://yoursite.com/2019/06/Avicii/","excerpt":"2019.6.6北京时间23:00:00(当地时间17:00:00)，Avicii的遗作专辑&lt;Tim&gt;发布。希望这永远不是鸽王的最后一张专辑。","text":"2019.6.6北京时间23:00:00(当地时间17:00:00)，Avicii的遗作专辑&lt;Tim&gt;发布。希望这永远不是鸽王的最后一张专辑。 曲目列表：(12 songs) Peace Of Mind Heaven SOS Tough Love Bad Reputation Ain’t A Thing Hold The Line Freak Excuse Me Mr Sir Heart Upon My Sleeve Never Leave Me Fades Away Rest in Peace.","categories":[{"name":"音乐","slug":"音乐","permalink":"http://yoursite.com/categories/音乐/"}],"tags":[{"name":"music","slug":"music","permalink":"http://yoursite.com/tags/music/"}]},{"title":"P3056 笨牛 Clumsy Cows [题解]","slug":"P3056题解","date":"2019-03-03T12:24:23.000Z","updated":"2019-04-27T09:20:22.100Z","comments":true,"path":"2019/03/P3056题解/","link":"","permalink":"http://yoursite.com/2019/03/P3056题解/","excerpt":"题目传送门 明显，这是一道用栈解决的水题。但是除了栈，还有另外一种简单一点的方法。","text":"题目传送门 明显，这是一道用栈解决的水题。但是除了栈，还有另外一种简单一点的方法。 切入正题： 1.栈(stack)运用STL中的#include&lt;stack&gt; stack&lt;类型&gt; st;压栈 st.push(元素);出栈 st.pop();获取栈顶元素 st.top();栈的大小(元素个数) st.size();判断栈是否为空(栈空输出true，反之亦然) st.empty(); 例：判断括号是否匹配bool check(string s)&#123; stack&lt;char&gt; st; for(int i=0; i&lt;s.size(); i++)&#123; if(s[i]=='(') st.push(s[i]); //左括号进栈 else&#123; //不是左括号就是右括号 if(st.empty()) return 0; //如果当前栈空，莫名其妙来一个右括号即为不匹配 else st.pop(); //说明栈里有待匹配的左括号，弹出一个（配对成功） &#125; &#125; return 1;&#125; 上代码真是喜闻乐见的一个环节呢 int ans=0;string s;stack&lt;char&gt; st;int main()&#123; cin&gt;&gt;s; for(int i=0; i&lt;s.size(); i++)&#123; if(s[i]=='(') st.push(s[i]); //左括号进栈 else&#123; //不是左括号就是右括号 if(st.empty())&#123;st.push('('); ans++;&#125; //注意。如果不匹配就说明需要括号反转，因此反转括号，ans++ else st.pop(); &#125; &#125; if(!st.empty()) ans+=st.size()/2; //如果剩下一堆左括号，说明需要反转一半的才能配对成功 cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; 2.加减计数法和栈的原理差不多，只不过简单易懂，不用掌握栈。时间的话让我们大声喊出：STL NB! 左括号+1，右括号-1。如果匹配的话就是0了。 当然也有反例：())(单纯判断最终结果是否为0会出错WA 因此，我们可以发现：如果当前为0(栈空)再加入一个右括号那就需要反转了 string s;int ans=0,p=0;int main()&#123; cin&gt;&gt;s; for(int i=0; i&lt;s.size(); i++)&#123; if(s[i]=='(') p++; //类似进栈 else&#123; //不是左括号就是右括号 if(p) p--; //有一个左括号等待配对，那就配对 else ans++,p++; //反转 &#125; &#125; ans+=p/2; //道理同栈 cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; 结尾小声bb：感觉题目背景尽是扯淡2333","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/题解/"}],"tags":[{"name":"栈","slug":"栈","permalink":"http://yoursite.com/tags/栈/"}]},{"title":"线段树 浅析","slug":"线段树浅析","date":"2019-02-24T10:08:51.000Z","updated":"2019-08-11T02:36:49.564Z","comments":true,"path":"2019/02/线段树浅析/","link":"","permalink":"http://yoursite.com/2019/02/线段树浅析/","excerpt":"线段树?线段树是一种二叉搜索树，与区间树相似，它将一个区间划分成一些单元区间，每个单元区间对应线段树中的一个叶结点。 使用线段树可以快速的查找某一个节点在若干条线段中出现的次数，时间复杂度为O(logN）。而未优化的空间复杂度为2N，因此有时需要离散化让空间压缩。","text":"线段树?线段树是一种二叉搜索树，与区间树相似，它将一个区间划分成一些单元区间，每个单元区间对应线段树中的一个叶结点。 使用线段树可以快速的查找某一个节点在若干条线段中出现的次数，时间复杂度为O(logN）。而未优化的空间复杂度为2N，因此有时需要离散化让空间压缩。 查询 修改 朴素算法 O(n) O(1) 前缀和 O(1) O(n) 树状数组 O(log2 n) O(log2 n) ST表 O(1) O(log2 n) 线段树 O(1) O(log2 n) 单调队列 O(1) 或许不能修改 线段树模版1 [区间最值，仅满足单点修改] 满足以下特性： 树中每一个节点，代表一个区间 根节点代表一个完整的期间[1,n] 每个叶子节点代表长度为1的区间[x,x]，即区间的一个元素 对于非叶子节点的每一个节点[l,r]，它的左儿子是[l,mid]，右儿子是[mid+1,r]。其中mid=(l+r)/2 一个完整二叉树中，根节点p的左儿子编号为p*2，右儿子编号为p*2+1。 Code&lt; / &gt; 节点声明(区间: l , r)(状态值(最值): dat)： struct data&#123; int l,r,dat;&#125;t[4*N]; 建树(区间: l , r)(状态值(最值)dat)： void build(int p,int l,int r) //p为当前的节点编号,l r 是当前要赋给t[p]的l r&#123; t[p].l=l,t[p].r=r; if(l==r)&#123;t[p].dat=a[l]; return;&#125; //递归到叶子节点，叶子节点的最值就是它本身 int mid=(l+r)/2; //对半剖分 build(p*2,l,mid); //左儿子 build(p*2+1,mid+1,r); //右儿子 t[p].dat=max(t[p*2].dat,t[p*2+1].dat); //最值，可换min&#125; 询问某区间[l,r]的最值： 1.该节点全覆盖时不再往下递归，但需返回该节点的值 2.该节点取中点mid后,观察是那一边（中点左右）完全没有覆盖则不再往下递归;否则都需要往下递归（含半边全覆盖，因为下一层会直接返回值） 3.该节点需返回两边递归后处理的结果（当然，如果只有一边递归，就直接返回这一边的值） int ask(int p,int l,int r)&#123; if(l&lt;=t[p].l &amp;&amp; t[p].r&lt;=r) return t[p].dat; int mid=(t[p].l+t[p].r)/2; int val=-999999999; //最值 if(l&lt;=mid) val=max(val,ask(p*2,l,r)); if(r&gt;mid) val=max(val,ask(p*2+1,l,r)); return val;&#125; 指定位置x ,修改值为v （递归过程同上）： void change(int p,int x,int v)&#123; if(t[p].l==t[p].r) &#123;t[p].dat=v; return;&#125; int mid=(t[p].l+t[p].r)/2; if(x&lt;=mid) change(p*2,x,v); else change(p*2+1,x,v); t[p].dat=max(t[p*2].dat,t[p*2+1].dat);&#125; 线段树模版2[满足区间修改] P3372 【模板】线段树 1 带延迟标记功能的线段树 核心代码 spread(int p)为延迟标记下移一层 注意：当该层打上标记后，表示该层内容已经修改，本层以下等待机会再修改。机会来之下一次修改或查询时经过此节点往下递归时。 void spread(int p)&#123; if(t[p].add&gt;0)&#123; t[2*p].dat+=t[p].add*(t[2*p].r-t[2*p].l+1); t[2*p+1].dat+=t[p].add*(t[2*p+1].r-t[2*p+1].l+1); t[2*p].add+=t[p].add; t[2*p+1].add+=t[p].add; t[p].add=0; &#125; &#125; 推荐题来做题吧！ I Hate It 最接近神的人 忠诚 树的统计 送花","categories":[{"name":"C++学习","slug":"C-学习","permalink":"http://yoursite.com/categories/C-学习/"}],"tags":[{"name":"线段树","slug":"线段树","permalink":"http://yoursite.com/tags/线段树/"}]},{"title":"RMQ问题&ST表 浅析","slug":"RMQ问题&ST表 浅析","date":"2019-02-15T13:21:21.000Z","updated":"2019-08-11T02:05:31.704Z","comments":true,"path":"2019/02/RMQ问题&ST表 浅析/","link":"","permalink":"http://yoursite.com/2019/02/RMQ问题&ST表 浅析/","excerpt":"什么是RMQ问题？RMQ(Range Min/Max Query): 对于长度为n的数组A，回答若干询问RMQ(A,i,j)(i,j&lt;=n-1)返回数组A中下标在i,j范围内的最小（大）值，即RMQ问题是指求区间最值的问题。 解决方式： 朴素算法：每查询一次为O(n) ST算法：高效，以O(n log n)的预处理代价，换取O(1)的查询时性能","text":"什么是RMQ问题？RMQ(Range Min/Max Query): 对于长度为n的数组A，回答若干询问RMQ(A,i,j)(i,j&lt;=n-1)返回数组A中下标在i,j范围内的最小（大）值，即RMQ问题是指求区间最值的问题。 解决方式： 朴素算法：每查询一次为O(n) ST算法：高效，以O(n log n)的预处理代价，换取O(1)的查询时性能 ST算法令：f[i,j]代表从第i个数起连续2^j个数中的最大值（因此要用倍增） 从下图可以看出：f[0][1]=max(f[0][0],f[1][0]), …… f[[0][2]=max(f[0][1],f[2][1]) …… 采用动态规划的思想：显然f[i,j]=max(f[i,j-1],f[i+2^(j-1),j-1]) 所以，我们需要建立ST表，也就是上文中的f数组。生成ST表是一次预处理，此后都是O(1)的查询了。 建立ST表for(int i=0; i&lt;=n; i++) f[i][0]=a[i]; //初始化，第0列(j=0)就是a[i]。for(int j=1; j&lt;=20; j++) //j&lt;20很大啦，够用！2^20=1048576 for(int i=0; i+(1&lt;&lt;j)&lt;=n+1; i++) f[i][j]=max(f[i][j-1],f[i+(1&lt;&lt;(j-1))][j-1]); 查询时，只需取在ST表中找2段头尾满足区间范围进行拼凑，有重叠覆盖不影响结果。 Why?我们来模拟一下： 设A=2，6，4，8，4，8，4，8求RMQ(A,0,5)[MAX值]=max(RMQ(A,0,3),RMQ(A,2,5))，无论是直接求还是分两段重复的区间求的结果都是8因为不是运算，所以有重叠部分是可以的哦！ 查询设：范围是 [m,n] ,这个范围不会是刚好2 ^k的长度，我们就用2段区间来拼凑： 即[m,m+2^k-1]和[n-2^k+1,n] (拼凑后头尾满足[m,n],中间允许重叠) 因此查询结果即为：RMQ[A,m,n]=max(f[m][k],f[n-(1&lt;&lt;k)+1][k]); 其中2^k&lt;=(n-m+1) 则 k=log2(n-m+1); 举个例子：查询RMQ[A,1,6]=max(f[1][2],f[3][2]) log对数函数这里的log来说一下，对数是对求幂的逆运算，正如除法是乘法的倒数 如果a^x =N（a&gt;0，且a≠1），那么数x叫做以a为底N的对数，记作x=loga N，读作以a为底N的对数，其中a叫做对数的底数，N叫做真数。 比如说2^5=32，log2 32=5，求的是n次方 ST表例题【模板】ST表-Luogu#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=2000001;int n,m,a[maxn],lg[maxn],f[maxn][25];int main()&#123; scanf(\"%d%d\",&amp;n,&amp;m); //读入&amp;预处理 for(int i=1; i&lt;=n; i++)&#123; scanf(\"%d\",&amp;a[i]); f[i][0]=a[i]; &#125; for(int j=1; j&lt;=20; j++) for(int i=1; i+(1&lt;&lt;j)&lt;=n+1;i++) f[i][j]=max(f[i][j-1],f[i+(1&lt;&lt;(j-1))][j-1]); //回答每个询问 for(int i=1; i&lt;=m; i++)&#123; int l,r; scanf(\"%d%d\",&amp;l,&amp;r); int k=log2(r-l+1),ans=max(f[l][k],f[r-(1&lt;&lt;k)+1][k]); //直接使用cmath头文件里的`log2`函数 printf(\"%d\\n\",ans); &#125; return 0;&#125; 质量检测-Luogu//裸的模版题，只不过是没有询问需要自己“手动添加”罢了//还有一个点就是题目中求的是min值就要将原模版中的所有max改成min才能pass哦#include&lt;bits/stdc++.h&gt;using namespace std;const int N=1000000+10;int f[N][25],n,m;int main()&#123; scanf(\"%d%d\",&amp;n,&amp;m); for(int i=1; i&lt;=n; i++) scanf(\"%d\",&amp;f[i][0]); for(int k=1; k&lt;=20; k++) for(int i=1; i&lt;=n; i++) if(i+(1&lt;&lt;k)-1&lt;=n) f[i][k]=min(f[i][k-1],f[i+(1&lt;&lt;(k-1))][k-1]); for(int i=1; i&lt;=n-m+1; i++)&#123; int s=log2(m); printf(\"%d\\n\",min(f[i][s],f[i+m-(1&lt;&lt;s)][s])); &#125; return 0;&#125;","categories":[{"name":"C++学习","slug":"C-学习","permalink":"http://yoursite.com/categories/C-学习/"}],"tags":[{"name":"RMQ问题","slug":"RMQ问题","permalink":"http://yoursite.com/tags/RMQ问题/"}]},{"title":"优雅地使用Hexo搭建自己的静态博客3","slug":"Hexo3","date":"2019-01-22T14:48:36.000Z","updated":"2019-04-27T09:23:57.960Z","comments":true,"path":"2019/01/Hexo3/","link":"","permalink":"http://yoursite.com/2019/01/Hexo3/","excerpt":"关联GitHub账号！看了之前的教程，你可能会有一个疑问：woc！输入密码真jb烦人！有没有什么方便的方法让我可以在提交时免密码登陆呢？ 为了每一次部署不必一种输入密码，我们可以生成秘钥，然后提交到GitHub，进行关联，那么你下次就不需要再输入密码了。免密提交： # 用你注册GitHub时的邮箱号，进行秘钥生成cd ~ssh-keygen -t rsa -C \"xxxxxxx@qq.com\"# 系统就会生成一个隐藏文件夹.sshcd .sshls# 复制公钥vim id_rsa.pub","text":"关联GitHub账号！看了之前的教程，你可能会有一个疑问：woc！输入密码真jb烦人！有没有什么方便的方法让我可以在提交时免密码登陆呢？ 为了每一次部署不必一种输入密码，我们可以生成秘钥，然后提交到GitHub，进行关联，那么你下次就不需要再输入密码了。免密提交： # 用你注册GitHub时的邮箱号，进行秘钥生成cd ~ssh-keygen -t rsa -C \"xxxxxxx@qq.com\"# 系统就会生成一个隐藏文件夹.sshcd .sshls# 复制公钥vim id_rsa.pub 在公钥出现后复制下来，切记不要把公钥泄露。大概是这样的： 来到GitHub，点击头像，进入设置，然后点击SSH and GPG keys，创建新的SSH，将之前复制的公钥黏贴，提交，OK。 记得，点击的是SSH keys那一行的新建按钮。 发布文章！创建新的文章终端进入blog文件夹，输入hexo new 文章名称。执行之后，就会在~/blog/source/_posts/博客名称.md里自动创建“博客名称”.md的markdown文件，然后你就可以输入内容。 文章front-matter.md是markdown的文件后缀名。在第一篇有介绍过用什么软件可以打开它。之后，你可以看到typora打开的窗口中上方有一个框框，储存的是文章的各种元素。它叫Front-matter，是文件最上方以 --- 分隔的区域，用于指定个别文件的变量，举例来说： ---title: Hello Worlddate: 2013/7/13 20:46:25--- 在typora中显示的是一个框框，是因为其主题的设置（美化）。在普通编辑器中看到的就是上面这个样子。 以下是预先定义的参数，您可在模板中使用这些参数值并加以利用。这里选取一些常用的： 参数 描述 默认值 layout 布局 title 标题 date 建立日期 文件建立日期 updated 更新日期 文件更新日期 comments 开启文章的评论功能 true tags 标签（不适用于分页） categories 分类（不适用于分页） 分类和标签只有文章支持分类和标签，您可以在 Front-matter 中设置。在其他系统中，分类和标签听起来很接近，但是在 Hexo 中两者有着明显的差别：分类具有顺序性和层次性，也就是说 Foo, Bar 不等于 Bar, Foo；而标签没有顺序和层次。 发布博文hexo ghexo d 然后去username.github.io查看，如果有你的博文在上面，那么就成功了！ 删除博文进入~/blog/source/_posts就可以看到你之前发的所有文章。直接删除文件并更新博客即可。 参考文献 https://www.jianshu.com/p/77db3862595c 欢迎提出意见！","categories":[{"name":"博客","slug":"博客","permalink":"http://yoursite.com/categories/博客/"}],"tags":[{"name":"blog","slug":"blog","permalink":"http://yoursite.com/tags/blog/"}]},{"title":"优雅地使用Hexo搭建自己的静态博客2","slug":"Hexo2","date":"2019-01-21T11:09:17.000Z","updated":"2019-04-27T09:24:05.110Z","comments":true,"path":"2019/01/Hexo2/","link":"","permalink":"http://yoursite.com/2019/01/Hexo2/","excerpt":"继续！既然我们已经完成了Hexo的安装，那么就是开始使用了。请确保以下步骤在你正确安装完Hexo之后进行。","text":"继续！既然我们已经完成了Hexo的安装，那么就是开始使用了。请确保以下步骤在你正确安装完Hexo之后进行。 创建一个blog文件夹打开终端，输入mkdir blog。这里的blog可以是你想要的名字，这个文件夹将会作为你今后的Hexo博客的根目录。你的主题设置、博客文章等都会保存在这里。 使用cd blog进入目录。记住这个代码，这将是你以后的常用指令（在你执行Hexo来更新、部署你的博客时，需要进入你的博客文件夹操作，否则会报错）。 开启本地服务既然配置完了Hexo，我们就可以开启本地服务了。进入文件夹，输入hexo s开启本地服务。接下来，你可以看到 把网址复制下来，输入到浏览器里打开，就可以看到类似于这样子的界面： 到这里说明你的环境以及没有问题了，成功了搭建起了博客框架。 注：hexo s这个命令其实挺有用的，可以看到编辑后博客的样子（不是网页！别人如果登陆这个本地网址也看不到你的博客），但用时比发布时间短，可以快速知道blog的样子。 GitHub Page关联GitHub简介，就是一个代码托管平台。有个功能叫做GitHub Page，用于静态页面的项目托管，Hexo博客一般会先选择将它托管在这里。先来注册一下：GitHub官网。可以看到这样： 输入username，注意一下，这里的名字将关联到你博客网址（GitHub版）的名称，慎重！我原来把residual打错了于是又折腾了一个23333！第二行输入邮箱、第三行输入密码。密码只输一次，小心一点。 题外话由于GitHub网站是纯英文的，没有翻译有些人可能看得难受。在这里推荐使用Chrome谷歌浏览器。它在浏览纯英文网页时会有一个网页翻译的功能，方便理解。 建立仓库注册完后显示的界面就是你的仪表盘。右上角找到新建图标，点击New repository，如图： 跳出该界面： 这里的owner就是你当前的用户名。创建仓库的名字必须为username.github.io（就是那个name的输入框里填写的内容），我的用户名为ResidualNight，因此我创建的仓库名就是ResidualNight.github.io，这是很关键的一点，很重要。输入名字后，直接点最下面绿色的按钮，创建新仓库。切记用户名的正确与否！ 关联博客打开blog根目录。这里有一个文件叫做”_config.yml”，打开。如果有好的编辑器可以用，如：visual studio code等，正常情况下直接用文本编辑可以打开。 找到如图所示的代码段，输入和我一样的内容。至于我的ResidualNight，替换成你自己的GitHub用户名。然后保存文件。 回到终端进入目录，输入命令（“#”为注释内容，不用输）： # 产生静态网页hexo g# 部署到GitHub page上hexo d 以后，我们在更新文章、主题设置时都会运用到这两个命令，注意顺序，先g后d。在hexo d后，会要求输入GitHub的账户名称和密码。 hexo g正常： hexo d输入用户名&amp;密码图示：这里注意一下，输入密码时一般是不显示你的密码的。 部署完了网页，就可以登陆网页了！浏览器输入username.github.io，就可以看到你的博客了。 参考文献 https://www.jianshu.com/p/77db3862595c 想知道根目录文件夹里的文件做什么的看这里：https://hexo.io/zh-cn/docs/setup 欢迎提出意见！","categories":[{"name":"博客","slug":"博客","permalink":"http://yoursite.com/categories/博客/"}],"tags":[{"name":"blog","slug":"blog","permalink":"http://yoursite.com/tags/blog/"}]},{"title":"优雅地使用Hexo搭建自己的静态博客1","slug":"Hexo1","date":"2019-01-20T08:19:22.000Z","updated":"2019-04-27T09:24:10.742Z","comments":true,"path":"2019/01/Hexo1/","link":"","permalink":"http://yoursite.com/2019/01/Hexo1/","excerpt":"开始如题，这个静态博客就是使用hexo制作的。如果你对此有兴趣，有探究精神（又闲着没有事），那么你可以来尝试制作一下你的blog！在这里，我会尽量用通俗一些的语言来阐述这一过程，那么我们开始吧！ 如果你是一个大佬，这一章的内容自行跳过。是大佬也不会来看我的博客了233","text":"开始如题，这个静态博客就是使用hexo制作的。如果你对此有兴趣，有探究精神（又闲着没有事），那么你可以来尝试制作一下你的blog！在这里，我会尽量用通俗一些的语言来阐述这一过程，那么我们开始吧！ 如果你是一个大佬，这一章的内容自行跳过。是大佬也不会来看我的博客了233 这里开始科普一下我们所需要的东西： Hexo是个什么玩意儿？看到标题，你可能会有些蒙圈：hexo是个什么鬼？这个很简单，你可以请教一下baidu以及官网。稍稍引用一下： hexo 正常来说，不需要部署到我们的服务器上。我们的服务器上保存的，其实是基于在hexo通过markdown编写的文章，然后hexo帮我们生成静态的html页面，然后，将生成的html上传到我们的服务器，这样就有了我们所看到的博客界面。简而言之：hexo是个静态页面生成、上传的工具。 简单来说，就是配置好了hexo后，你只用写出博客网站的markdown代码（保存在一定的地方），就可以让hexo帮助你制作出含有你的博文的网页。当然你也可以自己定制网页的自定义，比如说下载他人的主题，并按自己的想法进行改进。 许多大佬、或是萌新们都会使用hexo搭建blog，毕竟人家简单、自由度还高嘛。 Markdown又是个什么玩意儿？这个真的就只有baidu可以帮助你了：Markdown强行科普。其实就是在正常打字时加上一些特殊的符号让文章能够层次分明，是一种在博客、OI（编程界）里十分流行的文本语言，hexo用的就是这种流行的语言。至于具体用法，在上文的链接中有说明，如果可以，我会放到“文章”那一部分那里写～ 这里比较推荐的markdown书写工具是这个：typora，简洁好用，支持hexo格式。 ‘终端’科普现在有两个主流电脑操作系统： mac windows Mac的终端名称是终端（Terminal），打开它很简单，进入启动台查找或是使用聚焦搜索查找； Windows的终端名称一般叫做cmd，在“开始”菜单栏里找到它或是使用“运行”这个应用输入cmd（实在不会的找baidu） 打开了吗？就是你眼前这个黑黑的东西，最上方有一串白字，代表你当前的启动盘。具体怎么用等会说。 安装Hexo参考官网文档： 安装Hexo的支持Hexo的安装需要两个软件的支持，它们分别是： Node.js Git git安装windows：下载并安装 git（嫌下载速度慢的看这个git国内下载站注意看清楚版本号和windows版本，看不懂还是使用龟速下载比较好） mac：在终端输入brew install git或下载 安装程序 安装。 Node.js安装在这里用命令行安装可能讲的不太清楚。下载地址，下载安装。 对于Windows用户的建议：可以使用Git Bash，这是git for windows自带的一组程序，提供了Linux风格的shell。打开它的方法很简单，在桌面任意位置单击右键，选择“Git Bash Here”即可。由于Hexo的很多操作都涉及到命令行，您可以考虑始终使用Git Bash来进行操作。 安装Hexo！在完成上述安装后，安装hexo： 在终端里输入：npm install -g hexo-cli mac用户可能会报错。这里使用sudo npm install -g hexo-cli安装。 一些建议 Windows中：终端中Ctrl + C是stop的快捷键，不要使用Ctrl + C或Ctrl + V的快捷键，用右键单击标题栏。 出现问题找官网和百度 也可以去找一些其他人写的教程，我写的是通俗版的，但归根到底都是根据别人的教程不然我怎么搭建的博客233 哦对官网上也有b站的视频可以学习：https://hexo.io/zh-cn/docs/ 参考文献 https://www.jianshu.com/p/77db3862595c https://www.jianshu.com/p/a2fe56d11c4f https://hexo.io/zh-cn/docs/ 欢迎提出意见！","categories":[{"name":"博客","slug":"博客","permalink":"http://yoursite.com/categories/博客/"}],"tags":[{"name":"blog","slug":"blog","permalink":"http://yoursite.com/tags/blog/"}]},{"title":"Welcome","slug":"Welcome","date":"2019-01-18T14:35:11.000Z","updated":"2020-02-23T12:15:45.269Z","comments":true,"path":"2019/01/Welcome/","link":"","permalink":"http://yoursite.com/2019/01/Welcome/","excerpt":"Hello!很高兴认识你！ 这里是Residual Night的第一个个人博客，基于Hexo&amp;&amp;github搭建的静态博客。","text":"Hello!很高兴认识你！ 这里是Residual Night的第一个个人博客，基于Hexo&amp;&amp;github搭建的静态博客。 这是什么？在这个blog上，主要会发表一些我的一些idea和编程笔记。至于编程，我只是一个刚接触c++的普及组+选手而已（初中苣蒻，勿喷）。但我坚信，我会在OI的道路上砥砺前行的。 长风破浪会有时，直挂云帆济沧海。不管有没有人看得到，不管我会不会在这个博客上坚持下去，但这里总是一个梦想开始的地方。 test#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; ios::sync_with_stdio(); cout&lt;&lt;\"Hello World!\"&lt;&lt;endl; return 0;&#125;","categories":[{"name":"个人生活","slug":"个人生活","permalink":"http://yoursite.com/categories/个人生活/"}],"tags":[{"name":"personal","slug":"personal","permalink":"http://yoursite.com/tags/personal/"}]}]}