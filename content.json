{"meta":{"title":"Residual Night","subtitle":"Enjoy Coding!","description":null,"author":"WPY","url":"http://yoursite.com","root":"/"},"pages":[{"title":"404 Not Found","date":"2019-04-26T15:39:30.902Z","updated":"2019-04-26T15:39:30.892Z","comments":true,"path":"404.html","permalink":"http://yoursite.com/404.html","excerpt":"","text":"很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"分类","date":"2019-04-26T15:41:10.116Z","updated":"2019-04-26T15:41:10.100Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-04-26T15:40:29.179Z","updated":"2019-04-26T15:40:29.167Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"七下·生物复习1","slug":"七下·生物复习1","date":"2019-04-04T12:20:00.000Z","updated":"2019-04-08T14:50:34.160Z","comments":true,"path":"2019/04/04/七下·生物复习1/","link":"","permalink":"http://yoursite.com/2019/04/04/七下·生物复习1/","excerpt":"4.1.1 人的由来.人类的起源和发展人类起源的观点神创论 科学技术相对落后的古代 人们认为人是由神创造的 生物间无任何亲缘关系 进化论 建立者：达尔文 提出了人和现代类人猿的共同祖先是森林古猿","text":"4.1.1 人的由来.人类的起源和发展人类起源的观点神创论 科学技术相对落后的古代 人们认为人是由神创造的 生物间无任何亲缘关系 进化论 建立者：达尔文 提出了人和现代类人猿的共同祖先是森林古猿 现代类人猿与人类能否制造和使用工具是人和动物的本质区别 现代类人猿长臂猿、猩猩、大猩猩、黑猩猩 臂行 生活在热带、亚热带丛林 会使用天然工具，但不会制造工具 脑容量小，无语言文字能力 人类 直立行走 生活在农村、城市 制造并使用各种简单和复杂的工具 脑容量大，有很强的思维能力和语言文字能力 现代类人猿与人类的相似 复杂的大脑和宽阔的胸阔 与人类相似的面部表情和骨骼成分 行为表现及寿命长短 共同祖先——森林古猿 …… 森林古猿 距今1200多万年前 树栖为主的生活 靠前肢攀援和采集食物 野果 嫩芽 树叶 昆虫 …… 生活方式与现代类人猿基本相同 从猿到人的进化—&gt;现代类人猿少量森林古猿一直过着树栖的生活，经过漫长的年代进化成现代类人猿。 —&gt;人类地壳运动剧烈，地形气候发生变化，一些热带丛林变成稀树草原，一部分森林古猿不得不下地生活。下地生活的森林古猿形态结构、生活习性也逐渐发生变化，逐渐进化成人类。 发展变化行走方式 半直立行走—&gt;直立行走 【人猿分界的重要标志】 工具使用 不会使用工具—&gt;使用自然工具—&gt;制造和使用简单工具—&gt;制造和使用各种复杂工具 衣着 赤身裸体—&gt;懂得御寒、遮羞—&gt;穿衣美观 (直立行走)—&gt;前肢解放，使用制造工具—&gt;(使用火改善营养)—&gt;大脑越来越发达—&gt;(语言交流)—&gt;人类越来越强大 证据在东非大裂谷地区发现了许多早期古人类化石，说明这一地区在远古时期曾经是古人类活动的地方 距今300万年前的少女露西的骨骼化石 175万年前的古人类的遗物化石、石器化石 事实与观点事实事情的真实情况，包括事物、事件、事态，即客观存在的一切物体&amp;假象 e.g.: 穿金戴银。 观点指从一定的立场/角度出发，对事物/问题所持的看法 e.g.: 八成是个富二代。 事实&amp;观点的联系人们的观点是根据事实提出的。 对于同一个问题，因为研究的方法和手段不同，可能会发现不同的事实，提出不同的观点。 对于同一个事实，不同的人可能会有不同的观点。 4.1.2 人的由来.人的生殖生殖系统男性生殖系统内生殖器 睾丸：男性的主要生殖器官，产生精子，分泌雄性激素 附睾：贮存&amp;输送精子 输精管：一条细长的管道，左右各一条，输送精子 精囊腺&amp;前列腺：分泌黏液 外生殖器 阴囊：保护睾丸和附睾 阴茎：内有尿道，能排出精液&amp;尿液，能够把精子输送到女性的生殖器官阴道里去 女性生殖系统内生殖器 卵巢：女性的主要生殖器官，也是女性的性腺，产生卵细胞，分泌雌性激素 输卵管：输送卵细胞，精子和卵细胞在其相遇并结合形成受精卵 子宫：胚胎发育的场所 阴道：精子进入和胎儿产出的通道，也是月经流出的通道 外生殖器即外阴部 男女生殖细胞对比 生殖细胞 形态 大小 结构 男性 精子 外形像蝌蚪，头大尾长，能游动 男性体内最小的细胞，用显微镜可见 头部有细胞核 女性 卵细胞 球形 女性特有的人体最大的细胞，肉眼可见 细胞质中有卵黄 Others受精的场所是输卵管，胚胎发育的场所是子宫 男性产生生殖细胞的活动没有周期性 生殖过程精子—&gt;输卵管[精卵结合]—&gt;受精卵—&gt;胚泡—&gt;子宫内膜[在子宫内发育]—&gt;胚胎—&gt;胎儿[通过胎盘、脐带进行物质交换]—&gt;新生儿诞生[38周分娩] 1.受精卵的形成受精：精子与卵细胞结合形成受精卵的过程 卵巢产生卵细胞，排出后进入输卵管 精子(精液)进入阴道后，缓慢通过子宫，在输卵管内与卵细胞相遇 其中一个精子与卵细胞结合形成受精卵 2.胚胎发育过程 胚胎的发育从受精卵开始，受精卵不断进行细胞分裂，逐渐发育成胚泡。 胚泡缓慢移动到子宫，最终附在子宫内膜上，这个过程就是怀孕 胚泡在8周左右时间发育成胎儿(已经呈现出人的形态) 营养 初期，由卵细胞的卵黄提供 此后，胎儿生活在羊水(子宫内半透明液体)中。通过胎盘、脐带从母体获得所需要的营养物质&amp;氧；胎儿产生的二氧化碳等废物，通过胎盘从母体排出 分娩一般，从形成受精卵开始到第38周(266 days)时，胎儿就发育成熟了 胎儿&amp;胎盘从母体的阴道产出，这个过程为分娩 4.1.3 青春期身体变化 指从童年到成年的过渡阶段，是生殖器官从开始迅速发育到成熟的阶段 在个体之间存在着较大差异，男孩一般比女孩玩玩玩1-2 years 发育特点在生长激素作用下，身高突增是青春期的一个显著特点。男孩和女孩的体型开始发生变化，区别也越来越明显。这和睾丸分泌的雄性激素，卵巢分泌的雌性激素有关。 神经系统以及心脏和肺等器官的功能明显增强 脑的质量接近成人水平 心脏功能增强 肺活量显著增加 性发育性器官的发育&amp;性功能的成熟是青春期发育的突出特征 性器官：迅速发育、质量迅速增加 遗精&amp;月经遗精：指男孩有时在睡梦中精液自尿道排出的现象[精满自溢] 月经：指女孩每月一次的子宫出血现象 心理变化及卫生 强烈的独立意识，遇到挫折又有依赖性 内心世界逐渐复杂 性意识开始萌动：从初期的与异性疏远，到逐渐愿意与异性接近/对异性产生朦胧的依恋 Made By XMFLS WPY 2019.4","categories":[],"tags":[{"name":"study","slug":"study","permalink":"http://yoursite.com/tags/study/"}]},{"title":"P3056 笨牛 Clumsy Cows [题解]","slug":"P3056 笨牛Clumsy Cows 题解","date":"2019-03-03T12:24:23.000Z","updated":"2019-03-15T15:12:56.976Z","comments":true,"path":"2019/03/03/P3056 笨牛Clumsy Cows 题解/","link":"","permalink":"http://yoursite.com/2019/03/03/P3056 笨牛Clumsy Cows 题解/","excerpt":"题目传送门 明显，这是一道用栈解决的水题。但是除了栈，还有另外一种简单一点的方法。","text":"题目传送门 明显，这是一道用栈解决的水题。但是除了栈，还有另外一种简单一点的方法。 切入正题： 1.栈(stack)运用STL中的#include&lt;stack&gt; stack&lt;类型&gt; st;压栈 st.push(元素);出栈 st.pop();获取栈顶元素 st.top();栈的大小(元素个数) st.size();判断栈是否为空(栈空输出true，反之亦然) st.empty(); 例：判断括号是否匹配bool check(string s)&#123; stack&lt;char&gt; st; for(int i=0; i&lt;s.size(); i++)&#123; if(s[i]=='(') st.push(s[i]); //左括号进栈 else&#123; //不是左括号就是右括号 if(st.empty()) return 0; //如果当前栈空，莫名其妙来一个右括号即为不匹配 else st.pop(); //说明栈里有待匹配的左括号，弹出一个（配对成功） &#125; &#125; return 1;&#125; 上代码真是喜闻乐见的一个环节呢 int ans=0;string s;stack&lt;char&gt; st;int main()&#123; cin&gt;&gt;s; for(int i=0; i&lt;s.size(); i++)&#123; if(s[i]=='(') st.push(s[i]); //左括号进栈 else&#123; //不是左括号就是右括号 if(st.empty())&#123;st.push('('); ans++;&#125; //注意。如果不匹配就说明需要括号反转，因此反转括号，ans++ else st.pop(); &#125; &#125; if(!st.empty()) ans+=st.size()/2; //如果剩下一堆左括号，说明需要反转一半的才能配对成功 cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; 2.加减计数法和栈的原理差不多，只不过简单易懂，不用掌握栈。时间的话让我们大声喊出：STL NB! 左括号+1，右括号-1。如果匹配的话就是0了。 当然也有反例：())(单纯判断最终结果是否为0会出错WA 因此，我们可以发现：如果当前为0(栈空)再加入一个右括号那就需要反转了 string s;int ans=0,p=0;int main()&#123; cin&gt;&gt;s; for(int i=0; i&lt;s.size(); i++)&#123; if(s[i]=='(') p++; //类似进栈 else&#123; //不是左括号就是右括号 if(p) p--; //有一个左括号等待配对，那就配对 else ans++,p++; //反转 &#125; &#125; ans+=p/2; //道理同栈 cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; 结尾小声bb：感觉题目背景尽是扯淡2333","categories":[],"tags":[{"name":"栈","slug":"栈","permalink":"http://yoursite.com/tags/栈/"}]},{"title":"线段树 浅析","slug":"线段树 浅析","date":"2019-02-24T10:08:51.000Z","updated":"2019-04-23T11:53:00.537Z","comments":true,"path":"2019/02/24/线段树 浅析/","link":"","permalink":"http://yoursite.com/2019/02/24/线段树 浅析/","excerpt":"什么是线段树？线段树是一种二叉搜索树，与区间树相似，它将一个区间划分成一些单元区间，每个单元区间对应线段树中的一个叶结点。 使用线段树可以快速的查找某一个节点在若干条线段中出现的次数，时间复杂度为O(logN）。而未优化的空间复杂度为2N，因此有时需要离散化让空间压缩。","text":"什么是线段树？线段树是一种二叉搜索树，与区间树相似，它将一个区间划分成一些单元区间，每个单元区间对应线段树中的一个叶结点。 使用线段树可以快速的查找某一个节点在若干条线段中出现的次数，时间复杂度为O(logN）。而未优化的空间复杂度为2N，因此有时需要离散化让空间压缩。 线段树模版1 [区间最值，仅满足单点修改] 满足以下特性： 树中每一个节点，代表一个区间 根节点代表一个完整的期间[1,n] 每个叶子节点代表长度为1的区间[x,x]，即区间的一个元素 对于非叶子节点的每一个节点[l,r]，它的左儿子是[l,mid]，右儿子是[mid+1,r]。其中mid=(l+r)/2 一个完整二叉树中，根节点p的左儿子编号为p*2，右儿子编号为p*2+1。 建树节点声明(区间: l , r)(状态值(最值): dat)： struct data&#123; int l,r,dat;&#125;t[4*N]; 建树： void build(int p,int l,int r) //p为当前的节点编号,l r 是当前要赋给t[p]的l r&#123; t[p].l=l,t[p].r=r; if(l==r)&#123;t[p].dat=a[l]; return;&#125; //递归到叶子节点，叶子节点的最值就是它本身 int mid=(l+r)/2; //对半剖分 build(p*2,l,mid); //左儿子 build(p*2+1,mid+1,r); //右儿子 t[p].dat=max(t[p*2].dat,t[p*2+1].dat); //最值，可换min &#125; 未完待续","categories":[],"tags":[{"name":"线段树","slug":"线段树","permalink":"http://yoursite.com/tags/线段树/"}]},{"title":"RMQ问题&ST表 浅析","slug":"RMQ问题&ST表 浅析","date":"2019-02-15T13:21:21.000Z","updated":"2019-03-15T15:12:54.635Z","comments":true,"path":"2019/02/15/RMQ问题&ST表 浅析/","link":"","permalink":"http://yoursite.com/2019/02/15/RMQ问题&ST表 浅析/","excerpt":"什么是RMQ问题？RMQ(Range Min/Max Query): 对于长度为n的数组A，回答若干询问RMQ(A,i,j)(i,j&lt;=n-1)返回数组A中下标在i,j范围内的最小（大）值，即RMQ问题是指求区间最值的问题。 解决方式： 朴素算法：每查询一次为O(n) ST算法：高效，以O(n log n)的预处理代价，换取O(1)的查询时性能","text":"什么是RMQ问题？RMQ(Range Min/Max Query): 对于长度为n的数组A，回答若干询问RMQ(A,i,j)(i,j&lt;=n-1)返回数组A中下标在i,j范围内的最小（大）值，即RMQ问题是指求区间最值的问题。 解决方式： 朴素算法：每查询一次为O(n) ST算法：高效，以O(n log n)的预处理代价，换取O(1)的查询时性能 ST算法令：f[i,j]代表从第i个数起连续2^j个数中的最大值（因此要用倍增） 从下图可以看出：f[0][1]=max(f[0][0],f[1][0]), …… f[[0][2]=max(f[0][1],f[2][1]) …… 采用动态规划的思想：显然f[i,j]=max(f[i,j-1],f[i+2^(j-1),j-1]) 所以，我们需要建立ST表，也就是上文中的f数组。生成ST表是一次预处理，此后都是O(1)的查询了。 建立ST表for(int i=0; i&lt;=n; i++) f[i][0]=a[i]; //初始化，第0列(j=0)就是a[i]。for(int j=1; j&lt;=20; j++) //j&lt;20很大啦，够用！2^20=1048576 for(int i=0; i+(1&lt;&lt;j)&lt;=n+1; i++) f[i][j]=max(f[i][j-1],f[i+(1&lt;&lt;(j-1))][j-1]); 查询时，只需取在ST表中找2段头尾满足区间范围进行拼凑，有重叠覆盖不影响结果。 Why?我们来模拟一下： 设A=2，6，4，8，4，8，4，8求RMQ(A,0,5)[MAX值]=max(RMQ(A,0,3),RMQ(A,2,5))，无论是直接求还是分两段重复的区间求的结果都是8因为不是运算，所以有重叠部分是可以的哦！ 查询设：范围是 [m,n] ,这个范围不会是刚好2 ^k的长度，我们就用2段区间来拼凑： 即[m,m+2^k-1]和[n-2^k+1,n] (拼凑后头尾满足[m,n],中间允许重叠) 因此查询结果即为：RMQ[A,m,n]=max(f[m][k],f[n-(1&lt;&lt;k)+1][k]); 其中2^k&lt;=(n-m+1) 则 k=log2(n-m+1); 举个例子：查询RMQ[A,1,6]=max(f[1][2],f[3][2]) log对数函数这里的log来说一下，对数是对求幂的逆运算，正如除法是乘法的倒数 如果a^x =N（a&gt;0，且a≠1），那么数x叫做以a为底N的对数，记作x=loga N，读作以a为底N的对数，其中a叫做对数的底数，N叫做真数。 比如说2^5=32，log2 32=5，求的是n次方 ST表例题【模板】ST表-Luogu#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=2000001;int n,m,a[maxn],lg[maxn],f[maxn][25];int main()&#123; scanf(\"%d%d\",&amp;n,&amp;m); //读入&amp;预处理 for(int i=1; i&lt;=n; i++)&#123; scanf(\"%d\",&amp;a[i]); f[i][0]=a[i]; &#125; for(int j=1; j&lt;=20; j++) for(int i=1; i+(1&lt;&lt;j)&lt;=n+1;i++) f[i][j]=max(f[i][j-1],f[i+(1&lt;&lt;(j-1))][j-1]); //回答每个询问 for(int i=1; i&lt;=m; i++)&#123; int l,r; scanf(\"%d%d\",&amp;l,&amp;r); int k=log2(r-l+1),ans=max(f[l][k],f[r-(1&lt;&lt;k)+1][k]); //直接使用cmath头文件里的`log2`函数 printf(\"%d\\n\",ans); &#125; return 0;&#125; 质量检测-Luogu//裸的模版题，只不过是没有询问需要自己“手动添加”罢了//还有一个点就是题目中求的是min值就要将原模版中的所有max改成min才能pass哦#include&lt;bits/stdc++.h&gt;using namespace std;const int N=1000000+10;int f[N][25],n,m;int main()&#123; scanf(\"%d%d\",&amp;n,&amp;m); for(int i=1; i&lt;=n; i++) scanf(\"%d\",&amp;f[i][0]); for(int k=1; k&lt;=20; k++) for(int i=1; i&lt;=n; i++) if(i+(1&lt;&lt;k)-1&lt;=n) f[i][k]=min(f[i][k-1],f[i+(1&lt;&lt;(k-1))][k-1]); for(int i=1; i&lt;=n-m+1; i++)&#123; int s=log2(m); printf(\"%d\\n\",min(f[i][s],f[i+m-(1&lt;&lt;s)][s])); &#125; return 0;&#125;","categories":[],"tags":[{"name":"RMQ问题","slug":"RMQ问题","permalink":"http://yoursite.com/tags/RMQ问题/"}]},{"title":"优雅地使用Hexo搭建自己的静态博客3","slug":"优雅地使用Hexo搭建自己的静态博客3","date":"2019-01-22T14:48:36.000Z","updated":"2019-03-15T15:12:59.753Z","comments":true,"path":"2019/01/22/优雅地使用Hexo搭建自己的静态博客3/","link":"","permalink":"http://yoursite.com/2019/01/22/优雅地使用Hexo搭建自己的静态博客3/","excerpt":"关联GitHub账号！看了之前的教程，你可能会有一个疑问：woc！输入密码真jb烦人！有没有什么方便的方法让我可以在提交时免密码登陆呢？ 为了每一次部署不必一种输入密码，我们可以生成秘钥，然后提交到GitHub，进行关联，那么你下次就不需要再输入密码了。免密提交： # 用你注册GitHub时的邮箱号，进行秘钥生成cd ~ssh-keygen -t rsa -C \"xxxxxxx@qq.com\"# 系统就会生成一个隐藏文件夹.sshcd .sshls# 复制公钥vim id_rsa.pub","text":"关联GitHub账号！看了之前的教程，你可能会有一个疑问：woc！输入密码真jb烦人！有没有什么方便的方法让我可以在提交时免密码登陆呢？ 为了每一次部署不必一种输入密码，我们可以生成秘钥，然后提交到GitHub，进行关联，那么你下次就不需要再输入密码了。免密提交： # 用你注册GitHub时的邮箱号，进行秘钥生成cd ~ssh-keygen -t rsa -C \"xxxxxxx@qq.com\"# 系统就会生成一个隐藏文件夹.sshcd .sshls# 复制公钥vim id_rsa.pub 在公钥出现后复制下来，切记不要把公钥泄露。大概是这样的： 来到GitHub，点击头像，进入设置，然后点击SSH and GPG keys，创建新的SSH，将之前复制的公钥黏贴，提交，OK。 记得，点击的是SSH keys那一行的新建按钮。 发布文章！创建新的文章终端进入blog文件夹，输入hexo new 文章名称。执行之后，就会在~/blog/source/_posts/博客名称.md里自动创建“博客名称”.md的markdown文件，然后你就可以输入内容。 文章front-matter.md是markdown的文件后缀名。在第一篇有介绍过用什么软件可以打开它。之后，你可以看到typora打开的窗口中上方有一个框框，储存的是文章的各种元素。它叫Front-matter，是文件最上方以 --- 分隔的区域，用于指定个别文件的变量，举例来说： ---title: Hello Worlddate: 2013/7/13 20:46:25--- 在typora中显示的是一个框框，是因为其主题的设置（美化）。在普通编辑器中看到的就是上面这个样子。 以下是预先定义的参数，您可在模板中使用这些参数值并加以利用。这里选取一些常用的： 参数 描述 默认值 layout 布局 title 标题 date 建立日期 文件建立日期 updated 更新日期 文件更新日期 comments 开启文章的评论功能 true tags 标签（不适用于分页） categories 分类（不适用于分页） 分类和标签只有文章支持分类和标签，您可以在 Front-matter 中设置。在其他系统中，分类和标签听起来很接近，但是在 Hexo 中两者有着明显的差别：分类具有顺序性和层次性，也就是说 Foo, Bar 不等于 Bar, Foo；而标签没有顺序和层次。 发布博文hexo ghexo d 然后去username.github.io查看，如果有你的博文在上面，那么就成功了！ 删除博文进入~/blog/source/_posts就可以看到你之前发的所有文章。直接删除文件并更新博客即可。 参考文献 https://www.jianshu.com/p/77db3862595c 欢迎提出意见！","categories":[],"tags":[{"name":"blog","slug":"blog","permalink":"http://yoursite.com/tags/blog/"}]},{"title":"优雅地使用Hexo搭建自己的静态博客2","slug":"优雅地使用Hexo搭建自己的静态博客2","date":"2019-01-21T11:09:17.000Z","updated":"2019-03-15T15:13:03.271Z","comments":true,"path":"2019/01/21/优雅地使用Hexo搭建自己的静态博客2/","link":"","permalink":"http://yoursite.com/2019/01/21/优雅地使用Hexo搭建自己的静态博客2/","excerpt":"继续！既然我们已经完成了Hexo的安装，那么就是开始使用了。请确保以下步骤在你正确安装完Hexo之后进行。","text":"继续！既然我们已经完成了Hexo的安装，那么就是开始使用了。请确保以下步骤在你正确安装完Hexo之后进行。 创建一个blog文件夹打开终端，输入mkdir blog。这里的blog可以是你想要的名字，这个文件夹将会作为你今后的Hexo博客的根目录。你的主题设置、博客文章等都会保存在这里。 使用cd blog进入目录。记住这个代码，这将是你以后的常用指令（在你执行Hexo来更新、部署你的博客时，需要进入你的博客文件夹操作，否则会报错）。 开启本地服务既然配置完了Hexo，我们就可以开启本地服务了。进入文件夹，输入hexo s开启本地服务。接下来，你可以看到 把网址复制下来，输入到浏览器里打开，就可以看到类似于这样子的界面： 到这里说明你的环境以及没有问题了，成功了搭建起了博客框架。 注：hexo s这个命令其实挺有用的，可以看到编辑后博客的样子（不是网页！别人如果登陆这个本地网址也看不到你的博客），但用时比发布时间短，可以快速知道blog的样子。 GitHub Page关联GitHub简介，就是一个代码托管平台。有个功能叫做GitHub Page，用于静态页面的项目托管，Hexo博客一般会先选择将它托管在这里。先来注册一下：GitHub官网。可以看到这样： 输入username，注意一下，这里的名字将关联到你博客网址（GitHub版）的名称，慎重！我原来把residual打错了于是又折腾了一个23333！第二行输入邮箱、第三行输入密码。密码只输一次，小心一点。 题外话由于GitHub网站是纯英文的，没有翻译有些人可能看得难受。在这里推荐使用Chrome谷歌浏览器。它在浏览纯英文网页时会有一个网页翻译的功能，方便理解。 建立仓库注册完后显示的界面就是你的仪表盘。右上角找到新建图标，点击New repository，如图： 跳出该界面： 这里的owner就是你当前的用户名。创建仓库的名字必须为username.github.io（就是那个name的输入框里填写的内容），我的用户名为ResidualNight，因此我创建的仓库名就是ResidualNight.github.io，这是很关键的一点，很重要。输入名字后，直接点最下面绿色的按钮，创建新仓库。切记用户名的正确与否！ 关联博客打开blog根目录。这里有一个文件叫做”_config.yml”，打开。如果有好的编辑器可以用，如：visual studio code等，正常情况下直接用文本编辑可以打开。 找到如图所示的代码段，输入和我一样的内容。至于我的ResidualNight，替换成你自己的GitHub用户名。然后保存文件。 回到终端进入目录，输入命令（“#”为注释内容，不用输）： # 产生静态网页hexo g# 部署到GitHub page上hexo d 以后，我们在更新文章、主题设置时都会运用到这两个命令，注意顺序，先g后d。在hexo d后，会要求输入GitHub的账户名称和密码。 hexo g正常： hexo d输入用户名&amp;密码图示：这里注意一下，输入密码时一般是不显示你的密码的。 部署完了网页，就可以登陆网页了！浏览器输入username.github.io，就可以看到你的博客了。 参考文献 https://www.jianshu.com/p/77db3862595c 想知道根目录文件夹里的文件做什么的看这里：https://hexo.io/zh-cn/docs/setup 欢迎提出意见！","categories":[],"tags":[{"name":"blog","slug":"blog","permalink":"http://yoursite.com/tags/blog/"}]},{"title":"优雅地使用Hexo搭建自己的静态博客1","slug":"优雅地使用Hexo搭建自己的静态博客1","date":"2019-01-20T08:19:22.000Z","updated":"2019-03-15T15:13:06.837Z","comments":true,"path":"2019/01/20/优雅地使用Hexo搭建自己的静态博客1/","link":"","permalink":"http://yoursite.com/2019/01/20/优雅地使用Hexo搭建自己的静态博客1/","excerpt":"开始如题，这个静态博客就是使用hexo制作的。如果你对此有兴趣，有探究精神（又闲着没有事），那么你可以来尝试制作一下你的blog！在这里，我会尽量用通俗一些的语言来阐述这一过程，那么我们开始吧！ 如果你是一个大佬，这一章的内容自行跳过。是大佬也不会来看我的博客了233","text":"开始如题，这个静态博客就是使用hexo制作的。如果你对此有兴趣，有探究精神（又闲着没有事），那么你可以来尝试制作一下你的blog！在这里，我会尽量用通俗一些的语言来阐述这一过程，那么我们开始吧！ 如果你是一个大佬，这一章的内容自行跳过。是大佬也不会来看我的博客了233 这里开始科普一下我们所需要的东西： Hexo是个什么玩意儿？看到标题，你可能会有些蒙圈：hexo是个什么鬼？这个很简单，你可以请教一下baidu以及官网。稍稍引用一下： hexo 正常来说，不需要部署到我们的服务器上。我们的服务器上保存的，其实是基于在hexo通过markdown编写的文章，然后hexo帮我们生成静态的html页面，然后，将生成的html上传到我们的服务器，这样就有了我们所看到的博客界面。简而言之：hexo是个静态页面生成、上传的工具。 简单来说，就是配置好了hexo后，你只用写出博客网站的markdown代码（保存在一定的地方），就可以让hexo帮助你制作出含有你的博文的网页。当然你也可以自己定制网页的自定义，比如说下载他人的主题，并按自己的想法进行改进。 许多大佬、或是萌新们都会使用hexo搭建blog，毕竟人家简单、自由度还高嘛。 Markdown又是个什么玩意儿？这个真的就只有baidu可以帮助你了：Markdown强行科普。其实就是在正常打字时加上一些特殊的符号让文章能够层次分明，是一种在博客、OI（编程界）里十分流行的文本语言，hexo用的就是这种流行的语言。至于具体用法，在上文的链接中有说明，如果可以，我会放到“文章”那一部分那里写～ 这里比较推荐的markdown书写工具是这个：typora，简洁好用，支持hexo格式。 ‘终端’科普现在有两个主流电脑操作系统： mac windows Mac的终端名称是终端（Terminal），打开它很简单，进入启动台查找或是使用聚焦搜索查找； Windows的终端名称一般叫做cmd，在“开始”菜单栏里找到它或是使用“运行”这个应用输入cmd（实在不会的找baidu） 打开了吗？就是你眼前这个黑黑的东西，最上方有一串白字，代表你当前的启动盘。具体怎么用等会说。 安装Hexo参考官网文档： 安装Hexo的支持Hexo的安装需要两个软件的支持，它们分别是： Node.js Git git安装windows：下载并安装 git（嫌下载速度慢的看这个git国内下载站注意看清楚版本号和windows版本，看不懂还是使用龟速下载比较好） mac：在终端输入brew install git或下载 安装程序 安装。 Node.js安装在这里用命令行安装可能讲的不太清楚。下载地址，下载安装。 对于Windows用户的建议：可以使用Git Bash，这是git for windows自带的一组程序，提供了Linux风格的shell。打开它的方法很简单，在桌面任意位置单击右键，选择“Git Bash Here”即可。由于Hexo的很多操作都涉及到命令行，您可以考虑始终使用Git Bash来进行操作。 安装Hexo！在完成上述安装后，安装hexo： 在终端里输入：npm install -g hexo-cli mac用户可能会报错。这里使用sudo npm install -g hexo-cli安装。 一些建议 Windows中：终端中Ctrl + C是stop的快捷键，不要使用Ctrl + C或Ctrl + V的快捷键，用右键单击标题栏。 出现问题找官网和百度 也可以去找一些其他人写的教程，我写的是通俗版的，但归根到底都是根据别人的教程不然我怎么搭建的博客233 哦对官网上也有b站的视频可以学习：https://hexo.io/zh-cn/docs/ 参考文献 https://www.jianshu.com/p/77db3862595c https://www.jianshu.com/p/a2fe56d11c4f https://hexo.io/zh-cn/docs/ 欢迎提出意见！","categories":[],"tags":[{"name":"blog","slug":"blog","permalink":"http://yoursite.com/tags/blog/"}]},{"title":"Welcome","slug":"Welcome","date":"2019-01-18T14:35:11.000Z","updated":"2019-03-15T15:06:58.796Z","comments":true,"path":"2019/01/18/Welcome/","link":"","permalink":"http://yoursite.com/2019/01/18/Welcome/","excerpt":"Hello!这里是Residual Night的个人博客，基于Hexo&amp;&amp;github搭建的静态博客。也是我人生中第一个blog。","text":"Hello!这里是Residual Night的个人博客，基于Hexo&amp;&amp;github搭建的静态博客。也是我人生中第一个blog。 这是什么？在这个blog上，主要会发表一些我的一些idea和编程笔记。至于编程，我只是一个刚接触c++的普及组选手而已（初中苣蒻，勿喷）。但我坚信，我会在OI的道路上砥砺前行的。 长风破浪会有时，直挂云帆济沧海。不管有没有人看得到，不管我会不会在这个博客上坚持下去，但这里总是一个梦想开始的地方，isn’t it? test#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; cout&lt;&lt;\"Hello World!\"&lt;&lt;endl; return 0;&#125; $y=\\sum_{b}^{a}x^2$ 你好。 Hello. こんにちは。","categories":[],"tags":[{"name":"personal","slug":"personal","permalink":"http://yoursite.com/tags/personal/"}]}]}