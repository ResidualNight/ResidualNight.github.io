{"meta":{"title":"Residual Night","subtitle":"Enjoy Coding!","description":null,"author":"WPY","url":"http://yoursite.com","root":"/"},"pages":[{"title":"404 Not Found","date":"2019-08-13T05:41:16.142Z","updated":"2019-04-27T09:01:42.919Z","comments":true,"path":"404.html","permalink":"http://yoursite.com/404.html","excerpt":"","text":"很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"分类","date":"2019-04-26T15:41:10.116Z","updated":"2019-04-26T15:41:10.100Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"About","date":"2019-08-13T05:47:21.775Z","updated":"2019-08-13T05:47:21.766Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"一个来自XM的OIer，一个十足的苣蒻。 目前就读于XMFLS初中部，段排前百(太菜了)。 喜欢捣鼓各种东西，但有时候也因此坏了事。 初二，学习语言C++，NOIp提高(可能)水平233333。 具有肥宅属性。大爱犬走椛。 D.VA也好可爱啊23333 信仰之力：ᴀᴠɪᴄɪɪ ғᴏʀᴇᴠᴇʀ ◢ ◤"}],"posts":[{"title":"卡特兰数 浅析","slug":"卡特兰数","date":"2019-09-03T14:06:16.000Z","updated":"2019-09-05T14:56:37.801Z","comments":true,"path":"2019/09/03/卡特兰数/","link":"","permalink":"http://yoursite.com/2019/09/03/卡特兰数/","excerpt":"卡特兰数又称卡塔兰数 (Catalan Number),是组合数学中一个经常出现在各种计数问题中的数列。其前几项为： 1251442132429143048621679658786208012742900...","text":"卡特兰数又称卡塔兰数 (Catalan Number),是组合数学中一个经常出现在各种计数问题中的数列。其前几项为： 1251442132429143048621679658786208012742900... 公式求卡特兰数列的第n项 公式1$$f(n)=\\sum_{i=0}^{n-1}f(i)\\times f(n-i-1)$$公式2$$f(n)=\\frac{f(n-1)(fn-2)}{n+1}$$公式3$$f(n)=\\frac{C_{2n}^{n}}{n+1}$$公式4$$f(n)=C_{2n}^{n}-C_{2n}^{n-1}$$","categories":[{"name":"C++学习","slug":"C-学习","permalink":"http://yoursite.com/categories/C-学习/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://yoursite.com/tags/数论/"}]},{"title":"高精度运算","slug":"高精度运算","date":"2019-08-13T04:10:07.000Z","updated":"2019-09-02T14:53:10.850Z","comments":true,"path":"2019/08/13/高精度运算/","link":"","permalink":"http://yoursite.com/2019/08/13/高精度运算/","excerpt":"必要的高精度运算。","text":"必要的高精度运算。 高精加int i=1,x=0; memset(c,0,sizeof(c));while(i&lt;=la || i&lt;=lb) //只要i小于a或b的长度就的循环&#123; c[i]+=a[i]+b[i]; //第i位加，注意含进位，给c数组 c[i+1]+=c[i]/10; //取该位置的进位 c[i]%=10; //留下没有进位的部分 i++;&#125;if(c[i]&gt;0) lc=i;else lc=i-1; //lc记录结果的长度 高精减int i=1; memset(c,0,sizeof(c));while(i&lt;=la)&#123; if(a[i]&lt;b[i]) a[i]+=10,a[i+1]--; c[i]=a[i]-b[i]; i++;&#125;lc=i;while(lc&gt;1 &amp;&amp; c[lc]==0) lc--; 高精乘memset(c,0,sizeof(c));for(int i=1; i&lt;=lb; i++)&#123; x=0; for(int k=1; k&lt;=la; k++)&#123; c[i+k-1]+=b[i]*a[k]+x; x=c[i+k-1]/10; c[i+k-1]%=10; &#125; c[i+la]=x;&#125;lc=la+lb;while(c[lc]==0 &amp;&amp; lc&gt;1) lc--; 单精乘高精「n\u0010!」 cin&gt;&gt;n;c[1]=l=1,x=0;for(int i=1; i&lt;=n; i++)&#123; x=0; for(int k=1; k&lt;=l; k++)&#123; c[k]=c[k]*i+x;x=c[j]/10; x=c[j]/10; c[j]%=10; &#125; while(x&gt;0)&#123; l++; c[l]=x%10; x/=10; &#125;&#125;for(int i:=l;i&gt;=1;i--) cout&lt;&lt;c[i]; 高精除单精for(int i=1; i&lt;=la; i++)&#123; c[i]=(x*10+a[i])/b; x=(x*10+a[i])%b;&#125;int p=1;while(c[p]==0 &amp;&amp; p&lt;la) p++;for(int i=p; i&lt;=la; i++) cout&lt;&lt;c[i];//最后的x为余数","categories":[{"name":"C++学习","slug":"C-学习","permalink":"http://yoursite.com/categories/C-学习/"}],"tags":[{"name":"高精","slug":"高精","permalink":"http://yoursite.com/tags/高精/"}]},{"title":"是基础算法！","slug":"基础算法","date":"2019-08-11T02:45:19.000Z","updated":"2019-08-23T02:17:55.607Z","comments":true,"path":"2019/08/11/基础算法/","link":"","permalink":"http://yoursite.com/2019/08/11/基础算法/","excerpt":"一些基础的算法。","text":"一些基础的算法。 最大公约数gcd开挂法：__gcd(a,b);STL大法好！！！(震耳欲聋) int gcd(int a,int b)&#123; if(b==0) return a; return gcd(b,a%b);&#125; 最大公约数与最小公倍数的关系gcd(a,b)*lcm(a,b)=ab 素数判断简单法暴力超时见祖宗 bool pand(int x) //x&gt;=3&#123; for(int i=2; i*i&lt;=x; i++) if(x%i==0) return 0; return 1;&#125; 筛法 取最小的素数2，筛去它的所有倍数 取未被筛最小的数（一定是素数），再筛去它的所有倍数 重复直至全部都是素数（取最小数只需到 sqrt(n) ） bool isprime[N]int n,ans=0;int main()&#123; memset(isprime,1,sizeof(isprime)); cin&gt;&gt;n; isprime[1]=0; for(int i=2; i&lt;=sqrt(n); i++) //生成 if(isprime[i]) for(int k=i*i; k&lt;=n; k+=i) isprime[k]=0; for(int i=2; i&lt;=n; i++) //输出 if(isprime[i]) &#123;ans++; cout&lt;&lt;i&lt;&lt;\" \";&#125; cout&lt;&lt;endl&lt;&lt;ans&lt;&lt;endl; return 0;&#125; 排序 选择排序for(int i=1; i&lt;=n-1; i++) for(int j=i+1; j&lt;=n; j++) if(a[i]&gt;a[j]) t=a[j],a[j]=a[i],a[i]=t; 冒泡排序对于接近有序的数列，加标记可以缩短排序时间 for(int i=n-1; i&gt;=1; i--)&#123; int p=0; for(int k=1; k&lt;=i; k++) if(d[k]&gt;d[k+1]) swap(d[k+1],d[k]),p=1; if(!p) break;&#125; 插入排序for(int i=2; i&lt;=n; i++)&#123; int p=a[i]; for(int k=i; k&gt;1 &amp;&amp; p&lt;a[k-1]; k--) a[k]=a[k-1]; a[k]=p;&#125; 快排sort(a+1,a+n+1,cmp);STL大法好！！！(再次破音) //手写快排void sort(int l,int r)&#123; int x=l,y=r,mid=a[(l+r)/2]; //mid:取一个数 do&#123; while(a[i]&lt;mid) x++; //左边起比mid小的数不动，x停在不比mid小的位子 while(mid&lt;a[y]) y--; //右边起比mid大的数不动，y停在不比mid大的位子 if(x&lt;=y) swap(a[x],a[y]),x++,y--; //如果x与y不交叉，交换x与y的数，x与y各再跳一步 &#125;while(x&lt;=y); //直至x与y交叉；mid已经在交叉的位置了 if(l&lt;y) qsort(l,y); //左边还有数(l&lt;y),递归 if(x&lt;r) qsort(x,r); //右边还有数(x&lt;r),递归&#125; 归并排序把两个已经有序的序列，归并成一个有序的序列 归并排序不会像快排那样蜕化为o(n2),最好和最坏的情况都是o(nlog2n) void merge_sort(int l,int r)&#123; if(l!=r)&#123; int mid=(l+r)/2; merge_sort(l,mid); merge_sort(mid+1,r); merge(l,mid,r); &#125;&#125; void merge(int p,int q,int r)&#123; int tt=p,tl=p,tr=q+1; //tt是tmp的指针，tl和tr是两个待合并有序序列的指针 while(tt&lt;=r)&#123; if(tl&lt;=q &amp;&amp; (tr&gt;r || a[tl]&lt;a[tr])) tmp[tt++]=a[tl++]; //tl还有元素，tr已经没有元素或tr指的元素较大 else tmp[tt++]=a[tr++]; //除上述情况的其他情况 &#125; for(int i=p;i&lt;=r;i++) a[i]=tmp[i]; //在tmp[]合并好后要搬到a[]中&#125; 二分a[ ]已经排序 递归算法bool find(int x,int l,int r) //x为要查找的数&#123; if(l&gt;r) return 0; int mid=(l+r)/2; if(x==a[mid]) return 1; if(x&lt;a[mid]) return find(x,l,mid-1); if(x&gt;a[mid]) return find(x,mid+1,r);&#125; 非递归算法bool find(int x,int l,int r)&#123; while(l&lt;=r)&#123; int mid=(l+r)/2; if(x==mid) return 1; if(x&lt;a[mid]) r=mid-1; else l=mid+1; &#125;&#125; 快速幂//输出：ans%pans=1,a%=p;while(b)&#123; if(b%2==1) ans=(ans*a)%p; a=(a*a)%p; b&gt;&gt;1;&#125;cout&lt;&lt;ans&lt;&lt;endl;","categories":[{"name":"C++学习","slug":"C-学习","permalink":"http://yoursite.com/categories/C-学习/"}],"tags":[{"name":"简单算法","slug":"简单算法","permalink":"http://yoursite.com/tags/简单算法/"}]},{"title":"R.I.P. Avicii ◢ ◤","slug":"Avicii","date":"2019-06-06T15:00:00.000Z","updated":"2019-07-18T09:19:55.428Z","comments":true,"path":"2019/06/06/Avicii/","link":"","permalink":"http://yoursite.com/2019/06/06/Avicii/","excerpt":"2019.6.6北京时间23:00:00(当地时间17:00:00)，Avicii的遗作专辑&lt;Tim&gt;发布。希望这永远不是鸽王的最后一张专辑。","text":"2019.6.6北京时间23:00:00(当地时间17:00:00)，Avicii的遗作专辑&lt;Tim&gt;发布。希望这永远不是鸽王的最后一张专辑。 曲目列表：(12 songs) Peace Of Mind Heaven SOS Tough Love Bad Reputation Ain’t A Thing Hold The Line Freak Excuse Me Mr Sir Heart Upon My Sleeve Never Leave Me Fades Away Rest in Peace.","categories":[{"name":"音乐","slug":"音乐","permalink":"http://yoursite.com/categories/音乐/"}],"tags":[{"name":"music","slug":"music","permalink":"http://yoursite.com/tags/music/"}]},{"title":"P3056 笨牛 Clumsy Cows [题解]","slug":"P3056 笨牛Clumsy Cows 题解","date":"2019-03-03T12:24:23.000Z","updated":"2019-04-27T09:20:22.100Z","comments":true,"path":"2019/03/03/P3056 笨牛Clumsy Cows 题解/","link":"","permalink":"http://yoursite.com/2019/03/03/P3056 笨牛Clumsy Cows 题解/","excerpt":"题目传送门 明显，这是一道用栈解决的水题。但是除了栈，还有另外一种简单一点的方法。","text":"题目传送门 明显，这是一道用栈解决的水题。但是除了栈，还有另外一种简单一点的方法。 切入正题： 1.栈(stack)运用STL中的#include&lt;stack&gt; stack&lt;类型&gt; st;压栈 st.push(元素);出栈 st.pop();获取栈顶元素 st.top();栈的大小(元素个数) st.size();判断栈是否为空(栈空输出true，反之亦然) st.empty(); 例：判断括号是否匹配bool check(string s)&#123; stack&lt;char&gt; st; for(int i=0; i&lt;s.size(); i++)&#123; if(s[i]=='(') st.push(s[i]); //左括号进栈 else&#123; //不是左括号就是右括号 if(st.empty()) return 0; //如果当前栈空，莫名其妙来一个右括号即为不匹配 else st.pop(); //说明栈里有待匹配的左括号，弹出一个（配对成功） &#125; &#125; return 1;&#125; 上代码真是喜闻乐见的一个环节呢 int ans=0;string s;stack&lt;char&gt; st;int main()&#123; cin&gt;&gt;s; for(int i=0; i&lt;s.size(); i++)&#123; if(s[i]=='(') st.push(s[i]); //左括号进栈 else&#123; //不是左括号就是右括号 if(st.empty())&#123;st.push('('); ans++;&#125; //注意。如果不匹配就说明需要括号反转，因此反转括号，ans++ else st.pop(); &#125; &#125; if(!st.empty()) ans+=st.size()/2; //如果剩下一堆左括号，说明需要反转一半的才能配对成功 cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; 2.加减计数法和栈的原理差不多，只不过简单易懂，不用掌握栈。时间的话让我们大声喊出：STL NB! 左括号+1，右括号-1。如果匹配的话就是0了。 当然也有反例：())(单纯判断最终结果是否为0会出错WA 因此，我们可以发现：如果当前为0(栈空)再加入一个右括号那就需要反转了 string s;int ans=0,p=0;int main()&#123; cin&gt;&gt;s; for(int i=0; i&lt;s.size(); i++)&#123; if(s[i]=='(') p++; //类似进栈 else&#123; //不是左括号就是右括号 if(p) p--; //有一个左括号等待配对，那就配对 else ans++,p++; //反转 &#125; &#125; ans+=p/2; //道理同栈 cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; 结尾小声bb：感觉题目背景尽是扯淡2333","categories":[{"name":"题解","slug":"题解","permalink":"http://yoursite.com/categories/题解/"}],"tags":[{"name":"栈","slug":"栈","permalink":"http://yoursite.com/tags/栈/"}]},{"title":"线段树 浅析","slug":"线段树 浅析","date":"2019-02-24T10:08:51.000Z","updated":"2019-08-11T02:36:49.564Z","comments":true,"path":"2019/02/24/线段树 浅析/","link":"","permalink":"http://yoursite.com/2019/02/24/线段树 浅析/","excerpt":"线段树?线段树是一种二叉搜索树，与区间树相似，它将一个区间划分成一些单元区间，每个单元区间对应线段树中的一个叶结点。 使用线段树可以快速的查找某一个节点在若干条线段中出现的次数，时间复杂度为O(logN）。而未优化的空间复杂度为2N，因此有时需要离散化让空间压缩。","text":"线段树?线段树是一种二叉搜索树，与区间树相似，它将一个区间划分成一些单元区间，每个单元区间对应线段树中的一个叶结点。 使用线段树可以快速的查找某一个节点在若干条线段中出现的次数，时间复杂度为O(logN）。而未优化的空间复杂度为2N，因此有时需要离散化让空间压缩。 查询 修改 朴素算法 O(n) O(1) 前缀和 O(1) O(n) 树状数组 O(log2 n) O(log2 n) ST表 O(1) O(log2 n) 线段树 O(1) O(log2 n) 单调队列 O(1) 或许不能修改 线段树模版1 [区间最值，仅满足单点修改] 满足以下特性： 树中每一个节点，代表一个区间 根节点代表一个完整的期间[1,n] 每个叶子节点代表长度为1的区间[x,x]，即区间的一个元素 对于非叶子节点的每一个节点[l,r]，它的左儿子是[l,mid]，右儿子是[mid+1,r]。其中mid=(l+r)/2 一个完整二叉树中，根节点p的左儿子编号为p*2，右儿子编号为p*2+1。 Code&lt; / &gt; 节点声明(区间: l , r)(状态值(最值): dat)： struct data&#123; int l,r,dat;&#125;t[4*N]; 建树(区间: l , r)(状态值(最值)dat)： void build(int p,int l,int r) //p为当前的节点编号,l r 是当前要赋给t[p]的l r&#123; t[p].l=l,t[p].r=r; if(l==r)&#123;t[p].dat=a[l]; return;&#125; //递归到叶子节点，叶子节点的最值就是它本身 int mid=(l+r)/2; //对半剖分 build(p*2,l,mid); //左儿子 build(p*2+1,mid+1,r); //右儿子 t[p].dat=max(t[p*2].dat,t[p*2+1].dat); //最值，可换min&#125; 询问某区间[l,r]的最值： 1.该节点全覆盖时不再往下递归，但需返回该节点的值 2.该节点取中点mid后,观察是那一边（中点左右）完全没有覆盖则不再往下递归;否则都需要往下递归（含半边全覆盖，因为下一层会直接返回值） 3.该节点需返回两边递归后处理的结果（当然，如果只有一边递归，就直接返回这一边的值） int ask(int p,int l,int r)&#123; if(l&lt;=t[p].l &amp;&amp; t[p].r&lt;=r) return t[p].dat; int mid=(t[p].l+t[p].r)/2; int val=-999999999; //最值 if(l&lt;=mid) val=max(val,ask(p*2,l,r)); if(r&gt;mid) val=max(val,ask(p*2+1,l,r)); return val;&#125; 指定位置x ,修改值为v （递归过程同上）： void change(int p,int x,int v)&#123; if(t[p].l==t[p].r) &#123;t[p].dat=v; return;&#125; int mid=(t[p].l+t[p].r)/2; if(x&lt;=mid) change(p*2,x,v); else change(p*2+1,x,v); t[p].dat=max(t[p*2].dat,t[p*2+1].dat);&#125; 线段树模版2[满足区间修改] P3372 【模板】线段树 1 带延迟标记功能的线段树 核心代码 spread(int p)为延迟标记下移一层 注意：当该层打上标记后，表示该层内容已经修改，本层以下等待机会再修改。机会来之下一次修改或查询时经过此节点往下递归时。 void spread(int p)&#123; if(t[p].add&gt;0)&#123; t[2*p].dat+=t[p].add*(t[2*p].r-t[2*p].l+1); t[2*p+1].dat+=t[p].add*(t[2*p+1].r-t[2*p+1].l+1); t[2*p].add+=t[p].add; t[2*p+1].add+=t[p].add; t[p].add=0; &#125; &#125; 推荐题来做题吧！ I Hate It 最接近神的人 忠诚 树的统计 送花","categories":[{"name":"C++学习","slug":"C-学习","permalink":"http://yoursite.com/categories/C-学习/"}],"tags":[{"name":"线段树","slug":"线段树","permalink":"http://yoursite.com/tags/线段树/"}]},{"title":"RMQ问题&ST表 浅析","slug":"RMQ问题&ST表 浅析","date":"2019-02-15T13:21:21.000Z","updated":"2019-08-11T02:05:31.704Z","comments":true,"path":"2019/02/15/RMQ问题&ST表 浅析/","link":"","permalink":"http://yoursite.com/2019/02/15/RMQ问题&ST表 浅析/","excerpt":"什么是RMQ问题？RMQ(Range Min/Max Query): 对于长度为n的数组A，回答若干询问RMQ(A,i,j)(i,j&lt;=n-1)返回数组A中下标在i,j范围内的最小（大）值，即RMQ问题是指求区间最值的问题。 解决方式： 朴素算法：每查询一次为O(n) ST算法：高效，以O(n log n)的预处理代价，换取O(1)的查询时性能","text":"什么是RMQ问题？RMQ(Range Min/Max Query): 对于长度为n的数组A，回答若干询问RMQ(A,i,j)(i,j&lt;=n-1)返回数组A中下标在i,j范围内的最小（大）值，即RMQ问题是指求区间最值的问题。 解决方式： 朴素算法：每查询一次为O(n) ST算法：高效，以O(n log n)的预处理代价，换取O(1)的查询时性能 ST算法令：f[i,j]代表从第i个数起连续2^j个数中的最大值（因此要用倍增） 从下图可以看出：f[0][1]=max(f[0][0],f[1][0]), …… f[[0][2]=max(f[0][1],f[2][1]) …… 采用动态规划的思想：显然f[i,j]=max(f[i,j-1],f[i+2^(j-1),j-1]) 所以，我们需要建立ST表，也就是上文中的f数组。生成ST表是一次预处理，此后都是O(1)的查询了。 建立ST表for(int i=0; i&lt;=n; i++) f[i][0]=a[i]; //初始化，第0列(j=0)就是a[i]。for(int j=1; j&lt;=20; j++) //j&lt;20很大啦，够用！2^20=1048576 for(int i=0; i+(1&lt;&lt;j)&lt;=n+1; i++) f[i][j]=max(f[i][j-1],f[i+(1&lt;&lt;(j-1))][j-1]); 查询时，只需取在ST表中找2段头尾满足区间范围进行拼凑，有重叠覆盖不影响结果。 Why?我们来模拟一下： 设A=2，6，4，8，4，8，4，8求RMQ(A,0,5)[MAX值]=max(RMQ(A,0,3),RMQ(A,2,5))，无论是直接求还是分两段重复的区间求的结果都是8因为不是运算，所以有重叠部分是可以的哦！ 查询设：范围是 [m,n] ,这个范围不会是刚好2 ^k的长度，我们就用2段区间来拼凑： 即[m,m+2^k-1]和[n-2^k+1,n] (拼凑后头尾满足[m,n],中间允许重叠) 因此查询结果即为：RMQ[A,m,n]=max(f[m][k],f[n-(1&lt;&lt;k)+1][k]); 其中2^k&lt;=(n-m+1) 则 k=log2(n-m+1); 举个例子：查询RMQ[A,1,6]=max(f[1][2],f[3][2]) log对数函数这里的log来说一下，对数是对求幂的逆运算，正如除法是乘法的倒数 如果a^x =N（a&gt;0，且a≠1），那么数x叫做以a为底N的对数，记作x=loga N，读作以a为底N的对数，其中a叫做对数的底数，N叫做真数。 比如说2^5=32，log2 32=5，求的是n次方 ST表例题【模板】ST表-Luogu#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=2000001;int n,m,a[maxn],lg[maxn],f[maxn][25];int main()&#123; scanf(\"%d%d\",&amp;n,&amp;m); //读入&amp;预处理 for(int i=1; i&lt;=n; i++)&#123; scanf(\"%d\",&amp;a[i]); f[i][0]=a[i]; &#125; for(int j=1; j&lt;=20; j++) for(int i=1; i+(1&lt;&lt;j)&lt;=n+1;i++) f[i][j]=max(f[i][j-1],f[i+(1&lt;&lt;(j-1))][j-1]); //回答每个询问 for(int i=1; i&lt;=m; i++)&#123; int l,r; scanf(\"%d%d\",&amp;l,&amp;r); int k=log2(r-l+1),ans=max(f[l][k],f[r-(1&lt;&lt;k)+1][k]); //直接使用cmath头文件里的`log2`函数 printf(\"%d\\n\",ans); &#125; return 0;&#125; 质量检测-Luogu//裸的模版题，只不过是没有询问需要自己“手动添加”罢了//还有一个点就是题目中求的是min值就要将原模版中的所有max改成min才能pass哦#include&lt;bits/stdc++.h&gt;using namespace std;const int N=1000000+10;int f[N][25],n,m;int main()&#123; scanf(\"%d%d\",&amp;n,&amp;m); for(int i=1; i&lt;=n; i++) scanf(\"%d\",&amp;f[i][0]); for(int k=1; k&lt;=20; k++) for(int i=1; i&lt;=n; i++) if(i+(1&lt;&lt;k)-1&lt;=n) f[i][k]=min(f[i][k-1],f[i+(1&lt;&lt;(k-1))][k-1]); for(int i=1; i&lt;=n-m+1; i++)&#123; int s=log2(m); printf(\"%d\\n\",min(f[i][s],f[i+m-(1&lt;&lt;s)][s])); &#125; return 0;&#125;","categories":[{"name":"C++学习","slug":"C-学习","permalink":"http://yoursite.com/categories/C-学习/"}],"tags":[{"name":"RMQ问题","slug":"RMQ问题","permalink":"http://yoursite.com/tags/RMQ问题/"}]},{"title":"优雅地使用Hexo搭建自己的静态博客3","slug":"优雅地使用Hexo搭建自己的静态博客3","date":"2019-01-22T14:48:36.000Z","updated":"2019-04-27T09:23:57.960Z","comments":true,"path":"2019/01/22/优雅地使用Hexo搭建自己的静态博客3/","link":"","permalink":"http://yoursite.com/2019/01/22/优雅地使用Hexo搭建自己的静态博客3/","excerpt":"关联GitHub账号！看了之前的教程，你可能会有一个疑问：woc！输入密码真jb烦人！有没有什么方便的方法让我可以在提交时免密码登陆呢？ 为了每一次部署不必一种输入密码，我们可以生成秘钥，然后提交到GitHub，进行关联，那么你下次就不需要再输入密码了。免密提交： # 用你注册GitHub时的邮箱号，进行秘钥生成cd ~ssh-keygen -t rsa -C \"xxxxxxx@qq.com\"# 系统就会生成一个隐藏文件夹.sshcd .sshls# 复制公钥vim id_rsa.pub","text":"关联GitHub账号！看了之前的教程，你可能会有一个疑问：woc！输入密码真jb烦人！有没有什么方便的方法让我可以在提交时免密码登陆呢？ 为了每一次部署不必一种输入密码，我们可以生成秘钥，然后提交到GitHub，进行关联，那么你下次就不需要再输入密码了。免密提交： # 用你注册GitHub时的邮箱号，进行秘钥生成cd ~ssh-keygen -t rsa -C \"xxxxxxx@qq.com\"# 系统就会生成一个隐藏文件夹.sshcd .sshls# 复制公钥vim id_rsa.pub 在公钥出现后复制下来，切记不要把公钥泄露。大概是这样的： 来到GitHub，点击头像，进入设置，然后点击SSH and GPG keys，创建新的SSH，将之前复制的公钥黏贴，提交，OK。 记得，点击的是SSH keys那一行的新建按钮。 发布文章！创建新的文章终端进入blog文件夹，输入hexo new 文章名称。执行之后，就会在~/blog/source/_posts/博客名称.md里自动创建“博客名称”.md的markdown文件，然后你就可以输入内容。 文章front-matter.md是markdown的文件后缀名。在第一篇有介绍过用什么软件可以打开它。之后，你可以看到typora打开的窗口中上方有一个框框，储存的是文章的各种元素。它叫Front-matter，是文件最上方以 --- 分隔的区域，用于指定个别文件的变量，举例来说： ---title: Hello Worlddate: 2013/7/13 20:46:25--- 在typora中显示的是一个框框，是因为其主题的设置（美化）。在普通编辑器中看到的就是上面这个样子。 以下是预先定义的参数，您可在模板中使用这些参数值并加以利用。这里选取一些常用的： 参数 描述 默认值 layout 布局 title 标题 date 建立日期 文件建立日期 updated 更新日期 文件更新日期 comments 开启文章的评论功能 true tags 标签（不适用于分页） categories 分类（不适用于分页） 分类和标签只有文章支持分类和标签，您可以在 Front-matter 中设置。在其他系统中，分类和标签听起来很接近，但是在 Hexo 中两者有着明显的差别：分类具有顺序性和层次性，也就是说 Foo, Bar 不等于 Bar, Foo；而标签没有顺序和层次。 发布博文hexo ghexo d 然后去username.github.io查看，如果有你的博文在上面，那么就成功了！ 删除博文进入~/blog/source/_posts就可以看到你之前发的所有文章。直接删除文件并更新博客即可。 参考文献 https://www.jianshu.com/p/77db3862595c 欢迎提出意见！","categories":[{"name":"博客","slug":"博客","permalink":"http://yoursite.com/categories/博客/"}],"tags":[{"name":"blog","slug":"blog","permalink":"http://yoursite.com/tags/blog/"}]},{"title":"优雅地使用Hexo搭建自己的静态博客2","slug":"优雅地使用Hexo搭建自己的静态博客2","date":"2019-01-21T11:09:17.000Z","updated":"2019-04-27T09:24:05.110Z","comments":true,"path":"2019/01/21/优雅地使用Hexo搭建自己的静态博客2/","link":"","permalink":"http://yoursite.com/2019/01/21/优雅地使用Hexo搭建自己的静态博客2/","excerpt":"继续！既然我们已经完成了Hexo的安装，那么就是开始使用了。请确保以下步骤在你正确安装完Hexo之后进行。","text":"继续！既然我们已经完成了Hexo的安装，那么就是开始使用了。请确保以下步骤在你正确安装完Hexo之后进行。 创建一个blog文件夹打开终端，输入mkdir blog。这里的blog可以是你想要的名字，这个文件夹将会作为你今后的Hexo博客的根目录。你的主题设置、博客文章等都会保存在这里。 使用cd blog进入目录。记住这个代码，这将是你以后的常用指令（在你执行Hexo来更新、部署你的博客时，需要进入你的博客文件夹操作，否则会报错）。 开启本地服务既然配置完了Hexo，我们就可以开启本地服务了。进入文件夹，输入hexo s开启本地服务。接下来，你可以看到 把网址复制下来，输入到浏览器里打开，就可以看到类似于这样子的界面： 到这里说明你的环境以及没有问题了，成功了搭建起了博客框架。 注：hexo s这个命令其实挺有用的，可以看到编辑后博客的样子（不是网页！别人如果登陆这个本地网址也看不到你的博客），但用时比发布时间短，可以快速知道blog的样子。 GitHub Page关联GitHub简介，就是一个代码托管平台。有个功能叫做GitHub Page，用于静态页面的项目托管，Hexo博客一般会先选择将它托管在这里。先来注册一下：GitHub官网。可以看到这样： 输入username，注意一下，这里的名字将关联到你博客网址（GitHub版）的名称，慎重！我原来把residual打错了于是又折腾了一个23333！第二行输入邮箱、第三行输入密码。密码只输一次，小心一点。 题外话由于GitHub网站是纯英文的，没有翻译有些人可能看得难受。在这里推荐使用Chrome谷歌浏览器。它在浏览纯英文网页时会有一个网页翻译的功能，方便理解。 建立仓库注册完后显示的界面就是你的仪表盘。右上角找到新建图标，点击New repository，如图： 跳出该界面： 这里的owner就是你当前的用户名。创建仓库的名字必须为username.github.io（就是那个name的输入框里填写的内容），我的用户名为ResidualNight，因此我创建的仓库名就是ResidualNight.github.io，这是很关键的一点，很重要。输入名字后，直接点最下面绿色的按钮，创建新仓库。切记用户名的正确与否！ 关联博客打开blog根目录。这里有一个文件叫做”_config.yml”，打开。如果有好的编辑器可以用，如：visual studio code等，正常情况下直接用文本编辑可以打开。 找到如图所示的代码段，输入和我一样的内容。至于我的ResidualNight，替换成你自己的GitHub用户名。然后保存文件。 回到终端进入目录，输入命令（“#”为注释内容，不用输）： # 产生静态网页hexo g# 部署到GitHub page上hexo d 以后，我们在更新文章、主题设置时都会运用到这两个命令，注意顺序，先g后d。在hexo d后，会要求输入GitHub的账户名称和密码。 hexo g正常： hexo d输入用户名&amp;密码图示：这里注意一下，输入密码时一般是不显示你的密码的。 部署完了网页，就可以登陆网页了！浏览器输入username.github.io，就可以看到你的博客了。 参考文献 https://www.jianshu.com/p/77db3862595c 想知道根目录文件夹里的文件做什么的看这里：https://hexo.io/zh-cn/docs/setup 欢迎提出意见！","categories":[{"name":"博客","slug":"博客","permalink":"http://yoursite.com/categories/博客/"}],"tags":[{"name":"blog","slug":"blog","permalink":"http://yoursite.com/tags/blog/"}]},{"title":"优雅地使用Hexo搭建自己的静态博客1","slug":"优雅地使用Hexo搭建自己的静态博客1","date":"2019-01-20T08:19:22.000Z","updated":"2019-04-27T09:24:10.742Z","comments":true,"path":"2019/01/20/优雅地使用Hexo搭建自己的静态博客1/","link":"","permalink":"http://yoursite.com/2019/01/20/优雅地使用Hexo搭建自己的静态博客1/","excerpt":"开始如题，这个静态博客就是使用hexo制作的。如果你对此有兴趣，有探究精神（又闲着没有事），那么你可以来尝试制作一下你的blog！在这里，我会尽量用通俗一些的语言来阐述这一过程，那么我们开始吧！ 如果你是一个大佬，这一章的内容自行跳过。是大佬也不会来看我的博客了233","text":"开始如题，这个静态博客就是使用hexo制作的。如果你对此有兴趣，有探究精神（又闲着没有事），那么你可以来尝试制作一下你的blog！在这里，我会尽量用通俗一些的语言来阐述这一过程，那么我们开始吧！ 如果你是一个大佬，这一章的内容自行跳过。是大佬也不会来看我的博客了233 这里开始科普一下我们所需要的东西： Hexo是个什么玩意儿？看到标题，你可能会有些蒙圈：hexo是个什么鬼？这个很简单，你可以请教一下baidu以及官网。稍稍引用一下： hexo 正常来说，不需要部署到我们的服务器上。我们的服务器上保存的，其实是基于在hexo通过markdown编写的文章，然后hexo帮我们生成静态的html页面，然后，将生成的html上传到我们的服务器，这样就有了我们所看到的博客界面。简而言之：hexo是个静态页面生成、上传的工具。 简单来说，就是配置好了hexo后，你只用写出博客网站的markdown代码（保存在一定的地方），就可以让hexo帮助你制作出含有你的博文的网页。当然你也可以自己定制网页的自定义，比如说下载他人的主题，并按自己的想法进行改进。 许多大佬、或是萌新们都会使用hexo搭建blog，毕竟人家简单、自由度还高嘛。 Markdown又是个什么玩意儿？这个真的就只有baidu可以帮助你了：Markdown强行科普。其实就是在正常打字时加上一些特殊的符号让文章能够层次分明，是一种在博客、OI（编程界）里十分流行的文本语言，hexo用的就是这种流行的语言。至于具体用法，在上文的链接中有说明，如果可以，我会放到“文章”那一部分那里写～ 这里比较推荐的markdown书写工具是这个：typora，简洁好用，支持hexo格式。 ‘终端’科普现在有两个主流电脑操作系统： mac windows Mac的终端名称是终端（Terminal），打开它很简单，进入启动台查找或是使用聚焦搜索查找； Windows的终端名称一般叫做cmd，在“开始”菜单栏里找到它或是使用“运行”这个应用输入cmd（实在不会的找baidu） 打开了吗？就是你眼前这个黑黑的东西，最上方有一串白字，代表你当前的启动盘。具体怎么用等会说。 安装Hexo参考官网文档： 安装Hexo的支持Hexo的安装需要两个软件的支持，它们分别是： Node.js Git git安装windows：下载并安装 git（嫌下载速度慢的看这个git国内下载站注意看清楚版本号和windows版本，看不懂还是使用龟速下载比较好） mac：在终端输入brew install git或下载 安装程序 安装。 Node.js安装在这里用命令行安装可能讲的不太清楚。下载地址，下载安装。 对于Windows用户的建议：可以使用Git Bash，这是git for windows自带的一组程序，提供了Linux风格的shell。打开它的方法很简单，在桌面任意位置单击右键，选择“Git Bash Here”即可。由于Hexo的很多操作都涉及到命令行，您可以考虑始终使用Git Bash来进行操作。 安装Hexo！在完成上述安装后，安装hexo： 在终端里输入：npm install -g hexo-cli mac用户可能会报错。这里使用sudo npm install -g hexo-cli安装。 一些建议 Windows中：终端中Ctrl + C是stop的快捷键，不要使用Ctrl + C或Ctrl + V的快捷键，用右键单击标题栏。 出现问题找官网和百度 也可以去找一些其他人写的教程，我写的是通俗版的，但归根到底都是根据别人的教程不然我怎么搭建的博客233 哦对官网上也有b站的视频可以学习：https://hexo.io/zh-cn/docs/ 参考文献 https://www.jianshu.com/p/77db3862595c https://www.jianshu.com/p/a2fe56d11c4f https://hexo.io/zh-cn/docs/ 欢迎提出意见！","categories":[{"name":"博客","slug":"博客","permalink":"http://yoursite.com/categories/博客/"}],"tags":[{"name":"blog","slug":"blog","permalink":"http://yoursite.com/tags/blog/"}]},{"title":"Welcome","slug":"Welcome","date":"2019-01-18T14:35:11.000Z","updated":"2019-08-13T05:41:02.867Z","comments":true,"path":"2019/01/18/Welcome/","link":"","permalink":"http://yoursite.com/2019/01/18/Welcome/","excerpt":"Hello!很高兴认识你！ 这里是Residual Night的第一个个人博客，基于Hexo&amp;&amp;github搭建的静态博客。以Material X为主题。","text":"Hello!很高兴认识你！ 这里是Residual Night的第一个个人博客，基于Hexo&amp;&amp;github搭建的静态博客。以Material X为主题。 这是什么？在这个blog上，主要会发表一些我的一些idea和编程笔记。至于编程，我只是一个刚接触c++的普及组+选手而已（初中苣蒻，勿喷）。但我坚信，我会在OI的道路上砥砺前行的。 长风破浪会有时，直挂云帆济沧海。不管有没有人看得到，不管我会不会在这个博客上坚持下去，但这里总是一个梦想开始的地方。 test#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; ios::sync_with_stdio(); cout&lt;&lt;\"Hello World!\"&lt;&lt;endl; return 0;&#125;","categories":[{"name":"个人生活","slug":"个人生活","permalink":"http://yoursite.com/categories/个人生活/"}],"tags":[{"name":"personal","slug":"personal","permalink":"http://yoursite.com/tags/personal/"}]}]}