<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>2020Dash-3</title>
      <link href="/2020/02/2020Dash-3/"/>
      <url>/2020/02/2020Dash-3/</url>
      
        <content type="html"><![CDATA[<center><br><p class="large" style="color:#666">Final Dash</p><br><b style="font-size:.9em;color:#666">每日进步</b><br></center><a id="more"></a><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><btn class="regular"><a href="https://www.luogu.com.cn/problem/P2744" target="_blank" rel="noopener">P2744[USACO5.3]量取牛奶</a></btn><p>知识点：<strong>迭代加深，完全背包</strong></p><h1 id="复习1-迭代加深"><a href="#复习1-迭代加深" class="headerlink" title="复习1:迭代加深"></a>复习1:迭代加深</h1><h2 id="深搜"><a href="#深搜" class="headerlink" title="深搜"></a>深搜</h2><blockquote><p>从根节点一直往下走，直到叶子搜索完再返回上一层。</p></blockquote><p><img src="https://i.loli.net/2020/02/27/nyg4sBI8S3DoUEJ.png" alt="image.png"></p><p>深搜的缺点很明显：如果答案状态所在的结点深度不大，那么搜到这个结点之前，对非常深的状态进行的搜索都是徒劳的。</p><p><img src="https://i.loli.net/2020/02/27/w9zyJB7oORWMfxj.png" alt="image.png"></p><h2 id="广搜"><a href="#广搜" class="headerlink" title="广搜"></a>广搜</h2><blockquote><p>从根节点开始，一层层往下搜索，直到最后才能走到叶子节点。</p></blockquote><p><img src="https://i.loli.net/2020/02/27/f7dgZp25hGaCVQY.png" alt="image.png"></p><p>广搜的问题也很明显。如果目标状态的深度稍微深一些，用于保存状态的队列所需的空间就会指数级增长。</p><h2 id="两者结合？"><a href="#两者结合？" class="headerlink" title="两者结合？"></a>两者结合？</h2><blockquote><p>深搜广搜都有自己的缺点。迭代加深(<strong>iterative deepening</strong>,简称ID)则结合两者的优点，用深搜模拟广搜。为了避免过大的空间需求，必须使用深搜。为了避免搜索无用且过深的搜索树，必须按广搜的模式控制搜索深度。</p></blockquote><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>深搜之前，我们设定一个限定的深度，要求深搜不得超过这个深度。每一次深搜，我们检查当前所处的深度。如果达到限定的深度，立刻返回。一次完整的深搜完成，如果没有找到答案，增加限定的深度，继续ID。</p><p><img src="https://i.loli.net/2020/02/27/ZTJ1a4SxEpYGgbt.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> C++学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSP </tag>
            
            <tag> DP </tag>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020冲刺CSP-S&lt;2&gt; P5414[YNOI2019]排序</title>
      <link href="/2020/02/2020Dash-2/"/>
      <url>/2020/02/2020Dash-2/</url>
      
        <content type="html"><![CDATA[<center><br><p class="large" style="color:#666">Final Dash</p><br><b style="font-size:.9em;color:#666">日常更新</b><br></center><a id="more"></a><h1 id="审题"><a href="#审题" class="headerlink" title="审题"></a>审题</h1><btn class="regular"><a href="https://www.luogu.com.cn/problem/P5414" target="_blank" rel="noopener">传送门</a></btn><p><green><strong>首先要明确，我们的最优解是不可能把同一个数字转换两次的</strong></green>（很好想）</p><p>然后，奇怪的思路就来了：</p><blockquote><p>既然我们可以一次把它移到正确的位置上，那么这个数字就可以理解为直接被移走了。</p></blockquote><p>所以……</p><h1 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h1><p>题目被我们转化成了：<u>删除几个数字，使得数列单调递增，所求的是移走数字的最小和。 使得删除的和最小，就意味着留下的和最大。</u></p><p>那么问题就变成了：<strong>保留几个单调递增的数字，使得和最大。</strong></p><p>那就简单很多了。</p><h1 id="程序代码"><a href="#程序代码" class="headerlink" title="程序代码"></a>程序代码</h1><p><em>最长不降子序列变形</em></p><p><code>F[i]=max(a[i], f[j]+a[i])</code>其中，<code>j&lt;i`</code>a[j]&lt;=a[i]`</p><p><code>f[i]</code>表示以<code>a[i]</code>结尾的的不降序列的和的最大值；</p><p>初始值：<code>f[i]=a[i]</code></p><p>结果：<code>max(f[i])</code>即最优的序列以任意数结尾都有可能。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> T,n,a[N],f[M];</span><br><span class="line"><span class="keyword">int</span> sum,ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n; sum=ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;a[i]; sum+=a[i]; <span class="comment">//计算总和</span></span><br><span class="line">            f[i]=a[i]; <span class="comment">//初始化</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>; k&lt;i; k++)</span><br><span class="line">                <span class="keyword">if</span>(a[i]&gt;=a[k]) f[i]=max(f[i],f[k]+a[i]); <span class="comment">//dp求和找最大的上升子序列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) ans=max(ans,f[i]);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;sum-ans&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//最小代价</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSP </tag>
            
            <tag> 奇怪的思路 </tag>
            
            <tag> 单调队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020冲刺CSP-S&lt;1&gt; P1311选择客栈</title>
      <link href="/2020/02/2020Dash-1/"/>
      <url>/2020/02/2020Dash-1/</url>
      
        <content type="html"><![CDATA[<center><br><p class="large" style="color:#666">Final Dash</p><br><b style="font-size:.9em;color:#666">信竞路上的重要节点</b><br></center><a id="more"></a><details><summary>写在前面 👇</summary><p>今年的CSP-S就是初中生涯的最后一次竞赛了。初二成绩不理想（110左右，二等），希望初三拿个一等。而且，年段排名也掉到了70，副科炸开。所以，来个Ultra Dash吧。</p></details><h1 id="初审题"><a href="#初审题" class="headerlink" title="初审题"></a>初审题</h1><p>题目<btn class="regular"><a href="https://www.luogu.com.cn/problem/P1311" target="_blank" rel="noopener">传送门</a></btn></p><p>题目信息整理后如上图，要求求解的是同色调，且最低消费不超过他们支付能力的两两组合数目。</p><p>以上信息只要知道客栈编号，相应的色调，最低消费就都清楚了，可能很容易想到暴力搜索。</p><p><img src="https://i.loli.net/2020/02/27/Ywx8QlJnDhpTAqk.png" alt="数据整理"></p><h1 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h1><h2 id="法一：O-n-3"><a href="#法一：O-n-3" class="headerlink" title="法一：O(n^3)"></a>法一：O(n^3)</h2><p>直接进行暴力枚举，用<code>i,j</code>枚举两个人的客栈位置，判断区间是否合法，用<code>ans</code>统计并输出。</p><p>预估：过前两个测试点。约<red>20 pts</red></p><h2 id="法二：O-n-2"><a href="#法二：O-n-2" class="headerlink" title="法二：O(n^2)"></a>法二：O(n^2)</h2><p>在算法一大基础上进行优化。我们会发现算法一用了<strong>O(n)</strong>的时间来判断这个区间是否合法。如果我们做一些预处理，那么就可以节省这一部分的时间。</p><p>很快，就想到了<u>前缀和</u>。即从第一家客栈到目前的客栈为止符合消费能力的客栈数。  </p><p>预估：<red>50 pts</red></p><h2 id="法三O-n-k"><a href="#法三O-n-k" class="headerlink" title="法三O(n*k)"></a>法三O(n*k)</h2><blockquote><p>观察数据范围，10^5平方级别的算法会超时。观察到k（颜色）很小，这时应当尽量朝<code>O(n*k)</code>优化算法</p></blockquote><p>​     中间有好多位置我需要访问好多遍，能不能一遍完成呢。可以从左往右依次扫过去的过程中记下在<code>i</code>位置之前已经出现了几个颜色一样的了，记为<code>num[i]</code>，然后再保存一下当前最后的一个够便宜的客栈的位置，记为<code>last</code>，每次遇到一个新的当前颜色的客栈，我就给答案加上最后一个够便宜的客栈之前的相同颜色的个数，即就是加上<code>num[last]</code>。</p><p><img src="https://i.loli.net/2020/02/26/wJA9l4qBdDmvUgp.png" alt="法三"></p><p>预估：<red>60 pts</red></p><h2 id="法四：O-n"><a href="#法四：O-n" class="headerlink" title="法四：O(n)"></a>法四：O(n)</h2><p>通过观察数据范围，O(n*k)的算法也对于加强版数据会超时，这时就要继续将算法优化至<code>O(n)</code></p><blockquote><p>可以设置三个数组：</p><p>SZ1[X]: 色调X到当前客栈有几家</p><p>SZ3[X]: 上一次遇到不超过P的时间节点（客栈号）</p><p>SZ2[X]: 该时间点之前色调与i相同的客栈有几家</p></blockquote><p><img src="https://i.loli.net/2020/02/26/zDiInKrY9FAUc8e.png" alt="image.png"></p><p>​     <strong>细节：</strong>同色数目先统计再累加，所以不会出现自己和自己配对的情况。  </p><h1 id="加强"><a href="#加强" class="headerlink" title="加强"></a>加强</h1><p>法四可以过加强版<btn class="regular"><a href="https://www.luogu.com.cn/problem/P6032" target="_blank" rel="noopener">传送门</a></btn></p>]]></content>
      
      
      <categories>
          
          <category> C++学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSP </tag>
            
            <tag> 奇怪的思路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;蔚蓝Celeste&gt;失败和抑郁</title>
      <link href="/2019/11/Celeste/"/>
      <url>/2019/11/Celeste/</url>
      
        <content type="html"><![CDATA[<blockquote><p>为什么要登<em>山</em>？</p><p>因为<em>山</em>就在那里。</p></blockquote><p><strong>【游戏推荐】1.蔚蓝Celeste</strong></p><a id="more"></a><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&lt;<strong>蔚蓝山脉(Celeste)</strong>&gt;是一款由加拿大电子游戏设计师<strong>马特·索尔森（Matt Thorson）</strong>和<strong>诺尔·贝瑞（Noel Berry）</strong>所设计开发的平台类电子游戏。这个游戏最初是在一个为期四天的游戏设计比赛中设计出的原型作品，之后扩充成为了完整的版本。这款游戏在2018年1月在Microsoft Windows，任天堂Switch、PlayStation 4、Xbox One、MacOS和Linux平台上发行。</p><p>《蔚蓝》发行后随即获得大量好评，主要集中在其剧情和配乐方面。IGN给予该作<em>10/10分</em>，成为了2018年首款获得该分数的游戏。</p><p>聆听美妙的BGM：<a href="https://music.163.com/album?id=75137375" target="_blank" rel="noopener">网易云音乐上的 &lt;蔚蓝&gt;原声带</a></p><p><img src="https://i.loli.net/2019/11/03/lFqy32Ut4Nf8rM7.png" alt="开始界面"></p><p>玩了十几小时，前来推荐。</p><h1 id="游戏内容"><a href="#游戏内容" class="headerlink" title="游戏内容"></a>游戏内容</h1><p>虽然是一部看似简单的像素风游戏，但是却能把手残党虐得扎心。如你所见，整个游戏的目的就是登上蔚蓝山顶<del>（新出的第九章跑到了太空）</del>。不过，再次之前，你将遭遇到各种重重困难。</p><h2 id="剧情"><a href="#剧情" class="headerlink" title="剧情"></a>剧情</h2><p>在这个横版跳跃游戏中，存有一些感人的剧情是挺难能可贵的，每一章节的游戏机制、BOSS战，基本都会和剧情相挂钩。剧情的推进则是通过对话的方式进行。</p><p><img src="https://i.loli.net/2019/11/03/oQMCETZFldRfWVn.png" alt="剧情截图"></p><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p><img src="https://i.loli.net/2019/11/03/Peh4ZBmECkcMKjl.png" alt="Steam界面"></p><p>根据本人肝了近15小时的游戏，达到了第四章结束。</p><p><img src="https://i.loli.net/2019/11/03/3FPwHMXh5rDlTjW.png" alt="第四章完成"></p><p>但是，有一点极其重要。最好不要用键盘玩耍这个游戏，因为<del>你会不自觉地砸起键盘</del>键盘的手感没有手柄好，玩久了会手酸。这也促发了我买个手柄的想法<del>能否实现就看情况了2333</del>。</p><p>主角有左右位移和下蹲，方向键&lt;上&gt;只是作为引导方向使用。此外还有冲刺、抓墙、小跳这三种技能，较好操控，玩法多样。玩家们也自己研究出不少的跳跃、速通技巧。</p><h2 id="关卡设计"><a href="#关卡设计" class="headerlink" title="关卡设计"></a>关卡设计</h2><p>每个章节都会引入一些特殊的新机制。比如跳板，狂风，平移机械块，蓝色泡泡球等等，这些机制都让这个游戏的可玩性变得更高。</p><p><img src="https://i.loli.net/2019/11/03/eQvsHKjDJhIEfz6.png" alt="第一章游戏内截图"></p><p>其次，在首页的选择章节的设计也是让我觉得非常awesome(<del>运用自如</del></p><p><img src="https://i.loli.net/2019/11/03/Twu9bzF4cNKPSVW.png" alt="选章设计"></p><p>一个微缩的<strong>Celeste山</strong>模型，上面简略的内容都有在游戏内实现，比如右侧的缆车。在这里你可以看到各种统计：</p><p><img src="https://i.loli.net/2019/11/03/rJOv47x9fCYwESh.png" alt="统计"></p><p><del>玩的比较菜，别喷</del></p><p>另外，每一章有若干草莓、一张B面磁带和一颗蓝心，内容丰富。如果你想全收集的话，你将经历过死亡次数的洗礼和寻找的乐趣。千万不要查看攻略！第二章节的蓝心收集就挺有趣的，一张椅子上的旧书预示着一切。如果你是普通玩家，建议你收集草莓。</p><p>还有，游戏打开后的小图标就是一个像素草莓。</p><h2 id="小小吐槽"><a href="#小小吐槽" class="headerlink" title="小小吐槽"></a>小小吐槽</h2><p>我丶太丶难丶了！</p><p>如果你先游戏的正常章节（<strong>A面</strong>）不够难，还可以在其中收藏磁带（<strong>B面</strong>）然后进行挑战，然后在<strong>C面</strong>玩耍。</p><p>此外，你可以尝试全收集。还有一命通关<del>（是人？）</del>的金草莓等着你。</p><p>还不够，我求求你去速通ba。</p><p><img src="https://i.loli.net/2019/11/03/GzaIQ6FY4KvW9kT.png" alt="死亡记录"></p><p>其他真的没有什么好吐槽的了，就是一定要有耐心，不然你会体验到几天换一个<em>键盘/手柄</em>的奇妙生活。</p><h2 id="体验"><a href="#体验" class="headerlink" title="体验"></a>体验</h2><p>手感不错。</p><p>如果在某处卡住没有耐心，可以打开游戏的帮助模式<del>（挂b）</del>，进行章节跳跃或是调低倍数、无敌等，让一部分的玩家有游戏体验。</p><p>每一章都是由简单到困难，开篇部分会引出新的机制，让你做热身。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总的来说，这部作品的蕴意也很深。它甚至公开探讨了抑郁症这一话题：主人公与黑化的自己（内心）进行争斗，并取得胜利登上巅峰的故事让人感触极深。但你要是想要完成情节，要有自己的技术才行<del>（或者打开游戏的内置挂）</del>。</p><p>在我心中，它也是一部满分的作品，你可以在其中体验到失败豁达和成功的乐趣，然后大胆面对生活，寓意不错。</p><p>用来装B秀技术也是不错的选择。</p><p>另，别在做复习、工作等要紧之事时玩，耗时<del>一看我就是亲身经历233333</del></p><p>在STEAM上花了34买的，原价68。如果你真的想玩或是真的欣赏游戏这一门第九艺术，那么我个人认为这68元还是很值的。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p><del>看大佬视频猛如虎，自己操作像条狗</del></p><p><em>带上自己的一份热血与坚持，登上心中的那一座山</em></p><p><a href="https://store.steampowered.com/app/504230/Celeste/" target="_blank" rel="noopener">STEAM 链接</a></p><h1 id="2020-2"><a href="#2020-2" class="headerlink" title="2020.2"></a>2020.2</h1><p>似乎会持续更新。</p><fancybox><br><img src="https://i.loli.net/2020/02/27/I46DBpykfoJTd8K.png">&nbsp;<br><img src="https://i.loli.net/2020/02/27/rTQhVXgdZpKYlO9.png">&nbsp;<br><img src="https://i.loli.net/2020/02/27/3eNUlnohWGyv4fx.png">&nbsp;<br><img src="https://i.loli.net/2020/02/27/OUl6vYbne4RcfkB.png">&nbsp;<br><img src="https://i.loli.net/2020/02/27/HuP98dX75nGrVDa.png">&nbsp;<br><img src="https://i.loli.net/2020/02/27/tOWXxUFZm98v6Ln.png"><br></fancybox><p>登上了蔚蓝山顶。说实在的，打6A的时候都快被感动流泪了，故事线相当精彩。</p><p>还有BC面和DLC没有打，还会玩下去的。</p><p>不断的尝试，来之不易的成功，也许就是这个游戏的魅力。</p>]]></content>
      
      
      <categories>
          
          <category> 游戏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单机游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSP-S第二轮tips</title>
      <link href="/2019/10/2019CSP-S%E5%A4%8D%E8%B5%9Btips/"/>
      <url>/2019/10/2019CSP-S%E5%A4%8D%E8%B5%9Btips/</url>
      
        <content type="html"><![CDATA[<p>一些极其重要的提丶高丶组算法。</p><a id="more"></a><h1 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h1><p><a href="https://www.luogu.org/problem/P1577" target="_blank" rel="noopener">P1577</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100000</span>+<span class="number">1000</span>;</span><br><span class="line"><span class="keyword">int</span> n,p,d[N],l=<span class="number">1</span>,r=<span class="number">99999999</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">pand</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> sans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) sans+=d[i]/x;</span><br><span class="line"><span class="keyword">return</span> sans&gt;=p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;p;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line"><span class="keyword">double</span> a; <span class="built_in">cin</span>&gt;&gt;a;</span><br><span class="line">d[i]=<span class="keyword">int</span>(a*<span class="number">100</span>); <span class="comment">//化成整数做</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line"><span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(pand(mid)) l=mid+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">cout</span>&lt;&lt;fixed&lt;&lt;setprecision(<span class="number">2</span>)&lt;&lt;<span class="keyword">double</span>(r/<span class="number">100.0</span>)&lt;&lt;<span class="built_in">endl</span>,<span class="number">0</span>; <span class="comment">//还原</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h1><p><a href="https://www.luogu.org/problem/P1226" target="_blank" rel="noopener">P1226</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line">ll b,q,k,ans=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">kasm</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(q&gt;<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(q &amp; <span class="number">1</span> ==<span class="number">1</span>) ans=ans*b%k; <span class="comment">//不要忘记%</span></span><br><span class="line">b=b*b%k;</span><br><span class="line">q &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;b&gt;&gt;q&gt;&gt;k;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">cout</span>&lt;&lt;b&lt;&lt;<span class="string">"^"</span>&lt;&lt;q&lt;&lt;<span class="string">" mod "</span>&lt;&lt;k&lt;&lt;<span class="string">"="</span>&lt;&lt;kasm()%k&lt;&lt;<span class="built_in">endl</span>,<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h1><h2 id="深搜"><a href="#深搜" class="headerlink" title="深搜"></a>深搜</h2><p>###<a href="https://www.luogu.org/problem/P2919" target="_blank" rel="noopener">P2919</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n,m,a[<span class="number">1000</span>][<span class="number">1000</span>]=&#123;<span class="number">0</span>&#125;,b[<span class="number">1000</span>][<span class="number">1000</span>]=&#123;<span class="number">0</span>&#125;,ans=<span class="number">0</span>,flag,maxx;</span><br><span class="line"><span class="keyword">int</span> dx[]=&#123;<span class="number">0</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;,dy[]=&#123;<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>&#125;; <span class="comment">//方向数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> xx=x+dx[i],yy=y+dy[i];</span><br><span class="line">        <span class="keyword">if</span>(xx&gt;<span class="number">0</span> &amp;&amp; xx&lt;=n &amp;&amp; yy&gt;<span class="number">0</span> &amp;&amp; yy&lt;=m)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[x][y]==maxx &amp;&amp; a[xx][yy]&gt;maxx) &#123;flag=<span class="number">0</span>; <span class="keyword">continue</span>;&#125;</span><br><span class="line">            <span class="keyword">if</span>(!b[xx][yy] &amp;&amp; a[xx][yy]&lt;=a[x][y])</span><br><span class="line">            &#123;</span><br><span class="line">                b[xx][yy]=<span class="number">1</span>;</span><br><span class="line">                dfs(xx,yy);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>; k&lt;=m; k++)</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;a[i][k];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>; k&lt;=m; k++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i][k] &amp;&amp; !b[i][k])</span><br><span class="line">            &#123;</span><br><span class="line">                flag=<span class="number">1</span>; maxx=a[i][k];</span><br><span class="line">                dfs(i,k);</span><br><span class="line">                ans+=flag;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>###<a href="https://www.luogu.org/problem/P1506" target="_blank" rel="noopener">P1506</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">500</span>+<span class="number">1000</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,mp[N][N],ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> dx[]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,dy[]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">mp[x][y]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">4</span>; i++)&#123;</span><br><span class="line"><span class="keyword">int</span> x0=x+dx[i],y0=y+dy[i];</span><br><span class="line"><span class="keyword">if</span>(x0&gt;<span class="number">0</span> &amp;&amp; x&lt;=n &amp;&amp; y0&gt;<span class="number">0</span> &amp;&amp; y0&lt;=m &amp;&amp; !mp[x0][y0]) <span class="comment">//判断边界和障碍物</span></span><br><span class="line">      dfs(x0,y0);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>; k&lt;=m; k++)&#123;</span><br><span class="line"><span class="keyword">char</span> a; <span class="built_in">cin</span>&gt;&gt;a;</span><br><span class="line"><span class="keyword">if</span>(a==<span class="string">'*'</span>) mp[i][k]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123; <span class="comment">//边缘1</span></span><br><span class="line"><span class="keyword">if</span>(!mp[i][<span class="number">1</span>]) dfs(i,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(!mp[i][m]) dfs(i,m);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; i++)&#123; <span class="comment">//边缘2</span></span><br><span class="line"><span class="keyword">if</span>(!mp[<span class="number">1</span>][i]) dfs(<span class="number">1</span>,i);</span><br><span class="line"><span class="keyword">if</span>(!mp[n][i]) dfs(n,i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) <span class="comment">//统计未被淹没的地方</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>; k&lt;=m; k++)</span><br><span class="line"><span class="keyword">if</span>(!mp[i][k]) ans++;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>,<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="种子染色"><a href="#种子染色" class="headerlink" title="种子染色"></a>种子染色</h2><p><a href="https://www.luogu.org/problem/P1451" target="_blank" rel="noopener">P1451</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> m,n,a[<span class="number">200</span>][<span class="number">200</span>],ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">4</span>]=&#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,dy[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;n; k++)</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;a[i][k];</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;m || x&lt;<span class="number">0</span> || y&gt;n || y&lt;<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    a[x][y]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x2=x+dx[i],y2=y+dy[i];</span><br><span class="line">        <span class="keyword">if</span>(a[x2][y2]) dfs(x2,y2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;m&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;n; k++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> c; <span class="built_in">cin</span>&gt;&gt;c;</span><br><span class="line">            a[i][k]=c-<span class="string">'0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;n; k++)</span><br><span class="line">            <span class="keyword">if</span>(a[i][k]) ans++,dfs(i,k);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="记忆化搜索"><a href="#记忆化搜索" class="headerlink" title="记忆化搜索"></a>记忆化搜索</h2><p><a href="https://www.luogu.org/problem/P1434" target="_blank" rel="noopener">P1434</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100</span>+<span class="number">500</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,mp[N][N],f[N][N],ans=<span class="number">-99</span>;</span><br><span class="line"><span class="keyword">int</span> dx[]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,dy[]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(f[x][y]) <span class="keyword">return</span> f[x][y];</span><br><span class="line"><span class="keyword">int</span> sans=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">4</span>; i++)&#123;</span><br><span class="line"><span class="keyword">int</span> tx=x+dx[i],ty=y+dy[i];</span><br><span class="line"><span class="keyword">if</span>(tx&gt;<span class="number">0</span> &amp;&amp; tx&lt;=n &amp;&amp; ty&gt;<span class="number">0</span> &amp;&amp; ty&lt;=m &amp;&amp; mp[x][y]&gt;mp[tx][ty])</span><br><span class="line">sans=max(sans,dfs(tx,ty)+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">f[x][y]=sans; <span class="comment">//记忆化</span></span><br><span class="line"><span class="keyword">return</span> sans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>; k&lt;=m; k++)</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;mp[i][k];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>; k&lt;=m; k++)&#123;</span><br><span class="line">f[i][k]=dfs(i,k);</span><br><span class="line">ans=max(ans,f[i][k]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>,<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="动归"><a href="#动归" class="headerlink" title="动归"></a>动归</h1><h2 id="最长不降子序列"><a href="#最长不降子序列" class="headerlink" title="最长不降子序列"></a>最长不降子序列</h2><p><a href="https://www.luogu.org/problem/P1481" target="_blank" rel="noopener">P1481</a></p><blockquote><p><code>strstr(s1,s2)</code>判断<code>s2</code>是否<code>s1</code>的子串，没有找到返回<strong>NULL</strong>，找到则返回子串第一个字符的地址</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2000</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> n,f[N],ans=<span class="number">-999</span>;</span><br><span class="line"><span class="keyword">char</span> s[N][N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;s[i]; f[i]=<span class="number">1</span>; <span class="comment">//初始化</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=i<span class="number">-1</span>; k&gt;=<span class="number">1</span>; k--)</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strstr</span>(s[i],s[k])==s[i]) f[i]=max(f[k]+<span class="number">1</span>,f[i]); <span class="comment">//DP</span></span><br><span class="line">ans=max(ans,f[i]); <span class="comment">//更新</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>,<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最长上升子序列-LIS"><a href="#最长上升子序列-LIS" class="headerlink" title="最长上升子序列(LIS)"></a>最长上升子序列(<em>LIS</em>)</h2><p>例子：</p><p>有6个数，分别是： <code>1 7 6 2 3 4</code>求最长上升子序列。</p><blockquote><p>最长上升子序列的元素不一定相邻</p><p>最长上升子序列一定是原序列的子集</p></blockquote><p>所以这个例子中的<em>LIS</em>就是：1 2 3 4，共4个<br>$$<br>n^2<br>$$</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x) <span class="keyword">return</span>;</span><br><span class="line">    print(from[x]);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;a[x]&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//迭代输出</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">        dp[i]=<span class="number">1</span>; from[i]=<span class="number">0</span>; <span class="comment">//from:前驱记录</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>; k&lt;i; k++)</span><br><span class="line">            <span class="keyword">if</span>(a[k]&lt;d[i] &amp;&amp; dp[i]&lt;dp[k]+<span class="number">1</span>) dp[i]=dp[k]+<span class="number">1</span>,from[i]=k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans=dp[<span class="number">1</span>],p=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n ;i++) <span class="keyword">if</span>(ans&lt;dp[i]) ans=dp[i],p=i;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    print(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最长公共子序列-LCS"><a href="#最长公共子序列-LCS" class="headerlink" title="最长公共子序列(LCS)"></a>最长公共子序列(<em>LCS</em>)</h2><p><a href="https://www.luogu.org/problem/P1439" target="_blank" rel="noopener">P1439</a></p><p>使用<code>dp[i][j]</code>表示第一个串的前<code>i</code>位，第二个串的前<code>j</code>位的LCS长度</p><p>则状态转移方程为：</p><p><strong>1:</strong> 如果有新的公共元素(<code>A1[i]==A2[j]</code>)<br>$$<br>dp[i][j]=max(dp[i][j],dp[i-1][j-1]+1);<br>$$<br><strong>2:</strong> 如果无法更新公共元素<br>$$<br>dp[i][j]=max(dp[i-1][j],dp[i][j-1]);<br>$$</p><h3 id="朴实做法-n-2"><a href="#朴实做法-n-2" class="headerlink" title="朴实做法 (n^2)"></a>朴实做法 (n^2)</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) <span class="built_in">cin</span>&gt;&gt;a1[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; i++) <span class="built_in">cin</span>&gt;&gt;a2[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>; k&lt;=m; k++)&#123;</span><br><span class="line">        dp[i][k]=max(dp[i<span class="number">-1</span>][k],dp[i][k<span class="number">-1</span>]);</span><br><span class="line">        <span class="keyword">if</span>(a1[i]==a2[k]) dp[i][k]=max(dp[i][k],dp[i<span class="number">-1</span>][k<span class="number">-1</span>]+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">cout</span>&lt;&lt;dp[n][m]&lt;&lt;<span class="built_in">endl</span>,<span class="number">0</span>;</span><br></pre></td></tr></table></figure><p><del>实则爆零</del></p><h3 id="AC"><a href="#AC" class="headerlink" title="AC"></a>AC</h3><p> 以第一个串为标准，用第二个串来匹配第一个串，看能匹配多少 </p><p> 把第一个串<strong>离散化</strong>后的数组是满足上升，反过来，满足上升的也就是满足原串的排列顺序的 </p><p> 求一个<strong>最长不下降序列</strong></p><blockquote><p><code>lower_bound(begin,end,num)</code>：从数组的<code>begin</code>位置到<code>end-1</code>位置二分查找第一个大于或等于<code>num</code>的数字，找到返回该数字的地址，不存在则返回end。</p><p>通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。 </p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100000</span>+<span class="number">1000</span>;</span><br><span class="line"><span class="keyword">int</span> a[N],b[N],ma[N],ans=<span class="number">0</span>,f[N],p[N],n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">ma[a[i]]=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) <span class="built_in">cin</span>&gt;&gt;b[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(ma[b[i]]&gt;p[ans])&#123;</span><br><span class="line">p[++ans]=ma[b[i]];</span><br><span class="line">f[i]=ans; <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> k=lower_bound(p+<span class="number">1</span>,p+ans+<span class="number">1</span>,ma[b[i]])-p;</span><br><span class="line">p[k]=ma[b[i]];</span><br><span class="line">f[i]=k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>,<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h2><h3 id="P1417"><a href="#P1417" class="headerlink" title="P1417"></a><a href="https://www.luogu.org/problem/P1417" target="_blank" rel="noopener">P1417</a></h3><blockquote><p>平常做01背包的题时，由于i的价值永远是不变的，所以i讨论的顺序对结果不影响</p><p>但是这道题中，如果你先讨论了1号点，再讨论第二点，第二点的价值会减小，反之一号点会减小，这两个哪个更优是不确定的，所以如果你先讨论1号点就会错</p><p>由此，需要按优先度对所有点进行排序</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100000</span>+<span class="number">1000</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data</span>&#123;</span></span><br><span class="line">ll a,b,c;</span><br><span class="line">&#125;d[N];</span><br><span class="line">ll T,n,f[N],ans=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(data x,data y)</span></span>&#123;<span class="keyword">return</span> x.c*y.b&lt;y.c*x.b;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;T&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(ll i=<span class="number">1</span>; i&lt;=n; i++) <span class="built_in">cin</span>&gt;&gt;d[i].a;</span><br><span class="line"><span class="keyword">for</span>(ll i=<span class="number">1</span>; i&lt;=n; i++) <span class="built_in">cin</span>&gt;&gt;d[i].b;</span><br><span class="line"><span class="keyword">for</span>(ll i=<span class="number">1</span>; i&lt;=n; i++) <span class="built_in">cin</span>&gt;&gt;d[i].c;</span><br><span class="line">sort(d+<span class="number">1</span>,d+n+<span class="number">1</span>,cmp);</span><br><span class="line"><span class="keyword">for</span>(ll i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line"><span class="keyword">for</span>(ll k=T; k-d[i].c&gt;=<span class="number">0</span>; k--)</span><br><span class="line">f[k]=max(f[k],f[k-d[i].c]+d[i].a-k*d[i].b);</span><br><span class="line"><span class="keyword">for</span>(ll i=<span class="number">1</span>; i&lt;=T; i++) ans=max(ans,f[i]);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>,<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="P1510"><a href="#P1510" class="headerlink" title="P1510"></a><a href="https://www.luogu.org/problem/P1510" target="_blank" rel="noopener">P1510</a></h3><blockquote><p>用01背包求出当精卫剩下的体力为x时，她最多能填多少海。这样，她第一次能填完海时剩下的体力就是所需的最小体力。</p><p>最后添加一个搜索就完成了。</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> v,n,c,ans;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">100000</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;v&gt;&gt;n&gt;&gt;c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> a,b; <span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=c; k&gt;=b; k--)</span><br><span class="line">            f[k]=max(f[k],f[k-b]+a); <span class="comment">//填或不填</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> p=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=c; i++)</span><br><span class="line">        <span class="keyword">if</span>(f[i]&gt;=v) &#123;p=<span class="number">1</span>; ans=i; <span class="keyword">break</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span>(p) <span class="built_in">cout</span>&lt;&lt;c-ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"Impossible"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="P1855"><a href="#P1855" class="headerlink" title="P1855"></a><a href="https://www.luogu.org/problem/P1855" target="_blank" rel="noopener">P1855</a></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1000</span>;</span><br><span class="line"><span class="keyword">int</span> n,ma,ta,m[N],t[N],f[N][N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;ma&gt;&gt;ta;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;m[i]&gt;&gt;t[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=ma; k&gt;=m[i]; k--)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=ta; j&gt;=t[i]; j--)</span><br><span class="line">                f[k][j]=max(f[k][j],f[k-m[i]][j-t[i]]+<span class="number">1</span>); <span class="comment">//实现与否</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">cout</span>&lt;&lt;f[ma][ta]&lt;&lt;<span class="built_in">endl</span>,<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h2><h2 id="P1616"><a href="#P1616" class="headerlink" title="P1616"></a><a href="https://www.luogu.org/problem/P1616" target="_blank" rel="noopener">P1616</a></h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> v[<span class="number">100001</span>],t[<span class="number">100001</span>],f[<span class="number">100001</span>]; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; i++)</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;t[i]&gt;&gt;v[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=t[i]; k&lt;=n; k++)</span><br><span class="line">            f[k]=max(f[k],f[k-t[i]]+v[i]);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;f[n]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="CSP-S-problem-plan"><a href="#CSP-S-problem-plan" class="headerlink" title="CSP-S problem plan"></a>CSP-S problem plan</h1><blockquote><p>1.二分 (洛谷 1577)</p><p>2.快速幂 （洛谷 1226）</p><p>3.搜索<br>1&gt;.深搜  （洛谷2919）<br>2&gt;.广搜  （洛谷1506）<br>3&gt;.种子染色（洛谷1451）<br>3&gt;.记忆化搜索  （洛谷1434）</p><p>4.动规<br>1&gt;.最长不降子序列：1481<br>2&gt;.最长公共子序列：1439<br>3&gt;.01背包：1417 1510 1855<br>4&gt;.完全背包：1616<br>5&gt;.多重背包：1776<br>6&gt;.区间动规：3146</p><p>5.图论<br>1&gt;.最短路<br>dij  （堆优化）1629<br>floyed  1364<br>SPFA  1529<br>最短路计数 1144 </p><p>2&gt;.最小生成树<br>prim：1194<br>克鲁斯卡尔：1195</p><p>3&gt; targen强连通分量  1656</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> C++学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>卡特兰数 浅析</title>
      <link href="/2019/09/%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0/"/>
      <url>/2019/09/%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p><strong>卡特兰数</strong>又称<strong>卡塔兰数</strong> <em>(Catalan Number)</em>,是组合数学中一个经常出现在各种计数问题中的数列。其前几项为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">5</span><br><span class="line">14</span><br><span class="line">42</span><br><span class="line">132</span><br><span class="line">429</span><br><span class="line">1430</span><br><span class="line">4862</span><br><span class="line">16796</span><br><span class="line">58786</span><br><span class="line">208012</span><br><span class="line">742900</span><br><span class="line">...</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h1><p>求卡特兰数列的第n项</p><p><strong>公式1</strong><br>$$<br>f(n)=\sum_{i=0}^{n-1}f(i)\times f(n-i-1)<br>$$</p><p><strong>公式2</strong><br>$$<br>f(n)=\frac {f(n-1)\times(f\times n-2)}{n+1}<br>$$</p><p><strong>公式3</strong><br>$$<br>f(n)=\frac{C_{2n}^{n}}{n+1}<br>$$</p><p><strong>公式4</strong><br>$$<br>f(n)=C_{2n}^{n}-C_{2n}^{n-1}<br>$$</p><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>卡特兰数经常出现在OI以及ACM中，在生活中也有广泛的应用。</p><h2 id="进出栈问题"><a href="#进出栈问题" class="headerlink" title="进出栈问题"></a>进出栈问题</h2><p><strong>栈是一种先进后出（FILO,First In Last Out）的数据结构</strong></p><p>那么一个足够大的栈的进栈序列为1,2,3,⋯,n时有多少个不同的出栈序列？</p><blockquote><p>假设k为最后一个出栈的元素。比k早进栈且早出栈的有k-1个数，一共有<strong>f(k-1)</strong>种方案。比k晚进栈且早出栈的有n-k个数，一共有<strong>f(n-k)</strong>种方案。所以一共有<strong>f(k-1)*f(n-k)</strong>种方案。当k取不同值时，产生的出栈序列是互相独立的，因此可累加。因为k的取值范围是1~n，所以结果为<br>$$<br>f(n)=f(0)\times f(n-1)+f(1)\times f(n-2)+…+f(n-1)\times f(0)<br>$$<br>注意：n&gt;=2</p></blockquote><p>例题：<a href="https://www.luogu.org/problem/P1044" target="_blank" rel="noopener">P1044 栈</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> f[N];</span><br><span class="line">f[<span class="number">0</span>]=f[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=n; i++)</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;i; k++)</span><br><span class="line">      f[i]+=f[k]*f[i-k+<span class="number">1</span>];</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;f[n]&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><h2 id="二叉树的计数"><a href="#二叉树的计数" class="headerlink" title="二叉树的计数"></a>二叉树的计数</h2><p>已知一颗二叉树有n个结点，问：该二叉树能组成多少种不同的形态?</p><blockquote><p>假设如果采用中序遍历的话，根结点第k个被访问到，则根结点的左子树有<code>k-1</code>个点、根结点的右指数有<code>n-k</code>个点。k的取值范围为1到n。明显的卡特兰数。</p></blockquote><h2 id="AB排列问题"><a href="#AB排列问题" class="headerlink" title="AB排列问题"></a>AB排列问题</h2><p>有n个A和n个B排成一排，从第1个位置开始到任何位置，B的个数不能超过A的个数，这样的排列有多少种？</p><p>如：</p><p>n=1: AB</p><p>n=2: AABB ABAB</p><p>n=3: AAABBB AABABB AABBAB ABAABB ABABA</p><blockquote><p>在n*n的格子中，只在下三角行走，每次横或竖走一格，有多少种走法？</p><p>向右走相当于进栈(A)，向左走相当于出栈(B)，本质就是n个数出栈次序的问题。</p></blockquote><p><img src="http://images.cppblog.com/cppblog_com/miyu/450px-Catalan_number_4x4_grid_example.svg.png" alt="AB排列问题"></p><h2 id="乘法加括号"><a href="#乘法加括号" class="headerlink" title="乘法加括号"></a>乘法加括号</h2><p><strong>NOI 1988</strong></p><p>对于连乘：<br>$$<br>a[0]\times a[1]\times a[2]\times …\times a[n]<br>$$<br>加了括号后可以改变它的运算顺序，问有多少种不同的运算顺序？</p><blockquote><p>将其表示成一颗二叉树，把<code>*</code>逐个作为根，得到卡特兰数。</p></blockquote><h1 id="参考文献-amp-网址"><a href="#参考文献-amp-网址" class="headerlink" title="参考文献&amp;网址"></a>参考文献&amp;网址</h1><ul><li>&lt;信息学奥赛之数学一本通&gt;林厚从 主编, 东南大学出版社</li><li><a href="https://blog.csdn.net/wookaikaiko/article/details/81105031" target="_blank" rel="noopener">https://blog.csdn.net/wookaikaiko/article/details/81105031</a></li><li><a href="https://www.luogu.org/blog/Ning-H/solution-p1044" target="_blank" rel="noopener">https://www.luogu.org/blog/Ning-H/solution-p1044</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高精度运算</title>
      <link href="/2019/08/%E9%AB%98%E7%B2%BE%E5%BA%A6%E8%BF%90%E7%AE%97/"/>
      <url>/2019/08/%E9%AB%98%E7%B2%BE%E5%BA%A6%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<p>必要的高精度运算。</p><a id="more"></a><h1 id="高精加"><a href="#高精加" class="headerlink" title="高精加"></a>高精加</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i=<span class="number">1</span>,x=<span class="number">0</span>; <span class="built_in">memset</span>(c,<span class="number">0</span>,<span class="keyword">sizeof</span>(c));</span><br><span class="line"><span class="keyword">while</span>(i&lt;=la || i&lt;=lb) <span class="comment">//只要i小于a或b的长度就的循环</span></span><br><span class="line">&#123;</span><br><span class="line">  c[i]+=a[i]+b[i]; <span class="comment">//第i位加，注意含进位，给c数组</span></span><br><span class="line">    c[i+<span class="number">1</span>]+=c[i]/<span class="number">10</span>; <span class="comment">//取该位置的进位</span></span><br><span class="line">    c[i]%=<span class="number">10</span>; <span class="comment">//留下没有进位的部分</span></span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(c[i]&gt;<span class="number">0</span>) lc=i;</span><br><span class="line"><span class="keyword">else</span> lc=i<span class="number">-1</span>;       <span class="comment">//lc记录结果的长度</span></span><br></pre></td></tr></table></figure><h1 id="高精减"><a href="#高精减" class="headerlink" title="高精减"></a>高精减</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i=<span class="number">1</span>; <span class="built_in">memset</span>(c,<span class="number">0</span>,<span class="keyword">sizeof</span>(c));</span><br><span class="line"><span class="keyword">while</span>(i&lt;=la)&#123;</span><br><span class="line">  <span class="keyword">if</span>(a[i]&lt;b[i]) a[i]+=<span class="number">10</span>,a[i+<span class="number">1</span>]--;</span><br><span class="line">    c[i]=a[i]-b[i];</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br><span class="line">lc=i;</span><br><span class="line"><span class="keyword">while</span>(lc&gt;<span class="number">1</span> &amp;&amp; c[lc]==<span class="number">0</span>) lc--;</span><br></pre></td></tr></table></figure><h1 id="高精乘"><a href="#高精乘" class="headerlink" title="高精乘"></a>高精乘</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">memset</span>(c,<span class="number">0</span>,<span class="keyword">sizeof</span>(c));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=lb; i++)&#123;</span><br><span class="line">    x=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>; k&lt;=la; k++)&#123;</span><br><span class="line">    c[i+k<span class="number">-1</span>]+=b[i]*a[k]+x;</span><br><span class="line">      x=c[i+k<span class="number">-1</span>]/<span class="number">10</span>;</span><br><span class="line">      c[i+k<span class="number">-1</span>]%=<span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  c[i+la]=x;</span><br><span class="line">&#125;</span><br><span class="line">lc=la+lb;</span><br><span class="line"><span class="keyword">while</span>(c[lc]==<span class="number">0</span> &amp;&amp; lc&gt;<span class="number">1</span>) lc--;</span><br></pre></td></tr></table></figure><h1 id="单精乘高精"><a href="#单精乘高精" class="headerlink" title="单精乘高精"></a>单精乘高精</h1><p>「n!」</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">c[<span class="number">1</span>]=l=<span class="number">1</span>,x=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">  x=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>; k&lt;=l; k++)&#123;</span><br><span class="line">    c[k]=c[k]*i+x;x=c[j]/<span class="number">10</span>;</span><br><span class="line">      x=c[j]/<span class="number">10</span>;</span><br><span class="line">        c[j]%=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(x&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        l++;</span><br><span class="line">        c[l]=x%<span class="number">10</span>;</span><br><span class="line">        x/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i:=l;i&gt;=<span class="number">1</span>;i--) <span class="built_in">cout</span>&lt;&lt;c[i];</span><br></pre></td></tr></table></figure><h1 id="高精除单精"><a href="#高精除单精" class="headerlink" title="高精除单精"></a>高精除单精</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=la; i++)&#123;</span><br><span class="line">    c[i]=(x*<span class="number">10</span>+a[i])/b;</span><br><span class="line">    x=(x*<span class="number">10</span>+a[i])%b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> p=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(c[p]==<span class="number">0</span> &amp;&amp; p&lt;la) p++;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=p; i&lt;=la; i++) <span class="built_in">cout</span>&lt;&lt;c[i];</span><br><span class="line"><span class="comment">//最后的x为余数</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高精 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>是基础算法！</title>
      <link href="/2019/08/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
      <url>/2019/08/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>一些基础的算法。</p><a id="more"></a><h1 id="最大公约数gcd"><a href="#最大公约数gcd" class="headerlink" title="最大公约数gcd"></a>最大公约数gcd</h1><p><del>开挂法</del>：<code>__gcd(a,b);</code><del>STL大法好！！！(震耳欲聋)</del></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(b==<span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">  <span class="keyword">return</span> gcd(b,a%b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最大公约数与最小公倍数的关系<code>gcd(a,b)*lcm(a,b)=ab</code></p><h1 id="素数判断"><a href="#素数判断" class="headerlink" title="素数判断"></a>素数判断</h1><h2 id="简单法"><a href="#简单法" class="headerlink" title="简单法"></a>简单法</h2><p>暴力<del>超时见祖宗</del></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">pand</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="comment">//x&gt;=3</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i*i&lt;=x; i++)</span><br><span class="line">  <span class="keyword">if</span>(x%i==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="筛法"><a href="#筛法" class="headerlink" title="筛法"></a>筛法</h2><blockquote><p><strong><1></1></strong>取最小的素数2，筛去它的所有倍数</p><p><strong><2></2></strong>取未被筛最小的数（一定是素数），再筛去它的所有倍数</p><p><strong><3></3></strong>重复<strong><2></2></strong>直至全部都是素数（取最小数只需到 sqrt(n) ）</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> isprime[N]</span><br><span class="line"><span class="keyword">int</span> n,ans=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(isprime,<span class="number">1</span>,<span class="keyword">sizeof</span>(isprime));</span><br><span class="line">  <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">  isprime[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=<span class="built_in">sqrt</span>(n); i++) <span class="comment">//生成</span></span><br><span class="line">    <span class="keyword">if</span>(isprime[i]) <span class="keyword">for</span>(<span class="keyword">int</span> k=i*i; k&lt;=n; k+=i) isprime[k]=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=n; i++) <span class="comment">//输出</span></span><br><span class="line">      <span class="keyword">if</span>(isprime[i]) &#123;ans++; <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">" "</span>;&#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><p><img src="https://i.loli.net/2019/08/11/LDANzYjbrBI1u5v.png" alt="排序"></p><p><img src="https://i.loli.net/2019/08/12/PhaSnrtJA5me6ip.png" alt="排序"></p><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n<span class="number">-1</span>; i++)</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;=n; j++)</span><br><span class="line">    <span class="keyword">if</span>(a[i]&gt;a[j]) t=a[j],a[j]=a[i],a[i]=t;</span><br></pre></td></tr></table></figure><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p><em>对于接近有序的数列，加标记可以缩短排序时间</em></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>; i&gt;=<span class="number">1</span>; i--)&#123;</span><br><span class="line">  <span class="keyword">int</span> p=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>; k&lt;=i; k++)</span><br><span class="line">      <span class="keyword">if</span>(d[k]&gt;d[k+<span class="number">1</span>]) swap(d[k+<span class="number">1</span>],d[k]),p=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(!p) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=n; i++)&#123;</span><br><span class="line">  <span class="keyword">int</span> p=a[i];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> k=i; k&gt;<span class="number">1</span> &amp;&amp; p&lt;a[k<span class="number">-1</span>]; k--) a[k]=a[k<span class="number">-1</span>];</span><br><span class="line">  a[k]=p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h2><p><code>sort(a+1,a+n+1,cmp);</code><del>STL大法好！！！(再次破音)</del></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//手写快排</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> x=l,y=r,mid=a[(l+r)/<span class="number">2</span>]; <span class="comment">//mid:取一个数</span></span><br><span class="line">  <span class="keyword">do</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(a[i]&lt;mid) x++; <span class="comment">//左边起比mid小的数不动，x停在不比mid小的位子</span></span><br><span class="line">      <span class="keyword">while</span>(mid&lt;a[y]) y--; <span class="comment">//右边起比mid大的数不动，y停在不比mid大的位子</span></span><br><span class="line">      <span class="keyword">if</span>(x&lt;=y) swap(a[x],a[y]),x++,y--; <span class="comment">//如果x与y不交叉，交换x与y的数，x与y各再跳一步</span></span><br><span class="line">  &#125;<span class="keyword">while</span>(x&lt;=y); <span class="comment">//直至x与y交叉；mid已经在交叉的位置了</span></span><br><span class="line">  <span class="keyword">if</span>(l&lt;y) qsort(l,y); <span class="comment">//左边还有数(l&lt;y),递归</span></span><br><span class="line">   <span class="keyword">if</span>(x&lt;r) qsort(x,r); <span class="comment">//右边还有数(x&lt;r),递归</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>把两个已经有序的序列，归并成一个有序的序列</p><p><strong><u>归并排序不会像快排那样蜕化为o(n2),最好和最坏的情况都是o(nlog2n)</u></strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l!=r)&#123;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    merge_sort(l,mid);</span><br><span class="line">    merge_sort(mid+<span class="number">1</span>,r);</span><br><span class="line">      merge(l,mid,r);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> q,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> tt=p,tl=p,tr=q+<span class="number">1</span>; <span class="comment">//tt是tmp的指针，tl和tr是两个待合并有序序列的指针</span></span><br><span class="line">  <span class="keyword">while</span>(tt&lt;=r)&#123;</span><br><span class="line">    <span class="keyword">if</span>(tl&lt;=q &amp;&amp; (tr&gt;r || a[tl]&lt;a[tr])) tmp[tt++]=a[tl++];  <span class="comment">//tl还有元素，tr已经没有元素或tr指的元素较大</span></span><br><span class="line">     <span class="keyword">else</span> tmp[tt++]=a[tr++]; <span class="comment">//除上述情况的其他情况</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=p;i&lt;=r;i++) a[i]=tmp[i]; <span class="comment">//在tmp[]合并好后要搬到a[]中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h1><p>a[ ]已经排序</p><h2 id="递归算法"><a href="#递归算法" class="headerlink" title="递归算法"></a>递归算法</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> <span class="comment">//x为要查找的数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(l&gt;r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span>(x==a[mid]) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(x&lt;a[mid]) <span class="keyword">return</span> find(x,l,mid<span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">if</span>(x&gt;a[mid]) <span class="keyword">return</span> find(x,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="非递归算法"><a href="#非递归算法" class="headerlink" title="非递归算法"></a>非递归算法</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">      <span class="keyword">if</span>(x==mid) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span>(x&lt;a[mid]) r=mid<span class="number">-1</span>;</span><br><span class="line">      <span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//输出：ans%p</span></span><br><span class="line">ans=<span class="number">1</span>,a%=p;</span><br><span class="line"><span class="keyword">while</span>(b)&#123;</span><br><span class="line">  <span class="keyword">if</span>(b%<span class="number">2</span>==<span class="number">1</span>) ans=(ans*a)%p;</span><br><span class="line">  a=(a*a)%p;</span><br><span class="line">  b&gt;&gt;<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 简单算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>R.I.P. Avicii ◢ ◤</title>
      <link href="/2019/06/Avicii/"/>
      <url>/2019/06/Avicii/</url>
      
        <content type="html"><![CDATA[<p>2019.6.6北京时间23:00:00(当地时间17:00:00)，Avicii的遗作专辑<code>&lt;Tim&gt;</code>发布。希望这永远不是鸽王的最后一张专辑。</p><a id="more"></a><p>曲目列表：(12 songs)</p><ul><li>Peace Of Mind</li><li>Heaven</li><li>SOS</li><li>Tough Love</li><li>Bad Reputation</li><li>Ain’t A Thing</li><li>Hold The Line</li><li>Freak</li><li>Excuse Me Mr Sir</li><li>Heart Upon My Sleeve</li><li>Never Leave Me</li><li>Fades Away</li></ul><p>Rest in Peace.</p><p><img src="https://i.loli.net/2019/04/28/5cc5a73b9898d.jpeg" alt></p>]]></content>
      
      
      <categories>
          
          <category> 音乐 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> music </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P3056 笨牛 Clumsy Cows [题解]</title>
      <link href="/2019/03/P3056%E9%A2%98%E8%A7%A3/"/>
      <url>/2019/03/P3056%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P3056" target="_blank" rel="noopener">题目传送门</a></p><p>明显，这是一道用栈解决的<del>水</del>题。但是除了栈，还有另外一种简单一点的方法。</p><a id="more"></a><p>切入正题：</p><h1 id="1-栈-stack"><a href="#1-栈-stack" class="headerlink" title="1.栈(stack)"></a>1.栈(stack)</h1><p>运用<strong>STL</strong>中的<code>#include&lt;stack&gt;</code></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">stack</span>&lt;类型&gt; st;</span><br><span class="line">压栈 st.push(元素);</span><br><span class="line">出栈 st.pop();</span><br><span class="line">获取栈顶元素 st.top();</span><br><span class="line">栈的大小(元素个数) st.size();</span><br><span class="line">判断栈是否为空(栈空输出<span class="literal">true</span>，反之亦然) st.empty();</span><br></pre></td></tr></table></figure><h2 id="例：判断括号是否匹配"><a href="#例：判断括号是否匹配" class="headerlink" title="例：判断括号是否匹配"></a>例：判断括号是否匹配</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; st;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.size(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">'('</span>) st.push(s[i]); <span class="comment">//左括号进栈</span></span><br><span class="line">        <span class="keyword">else</span>&#123; <span class="comment">//不是左括号就是右括号</span></span><br><span class="line">            <span class="keyword">if</span>(st.empty()) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//如果当前栈空，莫名其妙来一个右括号即为不匹配</span></span><br><span class="line">            <span class="keyword">else</span> st.pop(); <span class="comment">//说明栈里有待匹配的左括号，弹出一个（配对成功）</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="上代码"><a href="#上代码" class="headerlink" title="上代码"></a>上代码</h2><p>真是喜闻乐见的一个环节呢</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; st;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.size(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">'('</span>) st.push(s[i]); <span class="comment">//左括号进栈</span></span><br><span class="line">        <span class="keyword">else</span>&#123; <span class="comment">//不是左括号就是右括号</span></span><br><span class="line">            <span class="keyword">if</span>(st.empty())&#123;st.push(<span class="string">'('</span>); ans++;&#125; <span class="comment">//注意。如果不匹配就说明需要括号反转，因此反转括号，ans++</span></span><br><span class="line">            <span class="keyword">else</span> st.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!st.empty()) ans+=st.size()/<span class="number">2</span>; <span class="comment">//如果剩下一堆左括号，说明需要反转一半的才能配对成功</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-加减计数法"><a href="#2-加减计数法" class="headerlink" title="2.加减计数法"></a>2.加减计数法</h1><p>和栈的原理差不多，只不过简单易懂，不用掌握栈。时间的话<del>让我们大声喊出：STL NB!</del></p><p>左括号+1，右括号-1。如果匹配的话就是0了。</p><p>当然也有反例：<code>())(</code>单纯判断最终结果是否为0会出错WA</p><p>因此，我们可以发现：如果当前为0(栈空)再加入一个右括号那就需要反转了</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>,p=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.size(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">'('</span>) p++; <span class="comment">//类似进栈</span></span><br><span class="line">        <span class="keyword">else</span>&#123; <span class="comment">//不是左括号就是右括号</span></span><br><span class="line">            <span class="keyword">if</span>(p) p--; <span class="comment">//有一个左括号等待配对，那就配对</span></span><br><span class="line">            <span class="keyword">else</span> ans++,p++; <span class="comment">//反转</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans+=p/<span class="number">2</span>; <span class="comment">//道理同栈</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结尾小声bb：<del>感觉题目背景尽是扯淡2333</del></p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线段树 浅析</title>
      <link href="/2019/02/%E7%BA%BF%E6%AE%B5%E6%A0%91%E6%B5%85%E6%9E%90/"/>
      <url>/2019/02/%E7%BA%BF%E6%AE%B5%E6%A0%91%E6%B5%85%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="线段树"><a href="#线段树" class="headerlink" title="线段树?"></a>线段树?</h1><p>线段树是一种二叉搜索树，与区间树相似，它将一个区间划分成一些单元区间，每个单元区间对应线段树中的一个叶结点。</p><p>使用线段树可以快速的查找某一个节点在若干条线段中出现的次数，时间复杂度为O(logN）。而未优化的空间复杂度为2N，因此有时需要离散化让空间压缩。</p><a id="more"></a><table><thead><tr><th style="text-align:left"></th><th>查询</th><th>修改</th></tr></thead><tbody><tr><td style="text-align:left">朴素算法</td><td><code>O(n)</code></td><td><code>O(1)</code></td></tr><tr><td style="text-align:left">前缀和</td><td><code>O(1)</code></td><td><code>O(n)</code></td></tr><tr><td style="text-align:left">树状数组</td><td><code>O(log2 n)</code></td><td><code>O(log2 n)</code></td></tr><tr><td style="text-align:left">ST表</td><td><code>O(1)</code></td><td><code>O(log2 n)</code></td></tr><tr><td style="text-align:left">线段树</td><td><code>O(1)</code></td><td><code>O(log2 n)</code></td></tr><tr><td style="text-align:left">单调队列</td><td><code>O(1)</code></td><td>或许不能修改</td></tr></tbody></table><h1 id="线段树模版1"><a href="#线段树模版1" class="headerlink" title="线段树模版1"></a>线段树模版1</h1><p><u> <strong>[区间最值，仅满足单点修改]</strong></u></p><p><strong>满足以下特性：</strong></p><blockquote><ol><li>树中每一个节点，代表一个区间</li><li>根节点代表一个完整的期间<code>[1,n]</code></li><li>每个叶子节点代表长度为1的区间<code>[x,x]</code>，即区间的一个元素</li><li>对于非叶子节点的每一个节点<code>[l,r]</code>，它的左儿子是<code>[l,mid]</code>，右儿子是<code>[mid+1,r]</code>。其中<code>mid=(l+r)/2</code></li><li>一个完整二叉树中，根节点p的左儿子编号为<code>p*2</code>，右儿子编号为<code>p*2+1</code>。</li></ol></blockquote><h2 id="Code-lt-gt"><a href="#Code-lt-gt" class="headerlink" title="Code&lt; / &gt;"></a>Code&lt; / &gt;</h2><ul><li>节点声明<strong>(区间: l , r)(状态值(最值): dat)</strong>：</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r,dat;</span><br><span class="line">&#125;t[<span class="number">4</span>*N];</span><br></pre></td></tr></table></figure><ul><li>建树<strong>(区间: l , r)(状态值(最值)dat)</strong>：</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> <span class="comment">//p为当前的节点编号,l r 是当前要赋给t[p]的l r</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    t[p].l=l,t[p].r=r;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;t[p].dat=a[l]; <span class="keyword">return</span>;&#125; <span class="comment">//递归到叶子节点，叶子节点的最值就是它本身</span></span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)/<span class="number">2</span>; <span class="comment">//对半剖分</span></span><br><span class="line">    build(p*<span class="number">2</span>,l,mid); <span class="comment">//左儿子</span></span><br><span class="line">    build(p*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r); <span class="comment">//右儿子</span></span><br><span class="line">    t[p].dat=max(t[p*<span class="number">2</span>].dat,t[p*<span class="number">2</span>+<span class="number">1</span>].dat); <span class="comment">//最值，可换min</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>询问某区间[l,r]的最值：</li></ul><blockquote><p>1.该节点全覆盖时不再往下递归，但需返回该节点的值</p><p>2.该节点取中点mid后,观察是那一边（中点左右）完全没有覆盖则不再往下递归;否则都需要往下递归（含半边全覆盖，因为下一层会直接返回值）</p><p>3.该节点需返回两边递归后处理的结果（当然，如果只有一边递归，就直接返回这一边的值）</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=t[p].l &amp;&amp; t[p].r&lt;=r) <span class="keyword">return</span> t[p].dat;</span><br><span class="line"><span class="keyword">int</span> mid=(t[p].l+t[p].r)/<span class="number">2</span>;</span><br><span class="line">  <span class="keyword">int</span> val=<span class="number">-999999999</span>; <span class="comment">//最值</span></span><br><span class="line">    <span class="keyword">if</span>(l&lt;=mid) val=max(val,ask(p*<span class="number">2</span>,l,r));</span><br><span class="line">    <span class="keyword">if</span>(r&gt;mid) val=max(val,ask(p*<span class="number">2</span>+<span class="number">1</span>,l,r));</span><br><span class="line">  <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>指定位置x ,修改值为v （递归过程同上）：</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> x,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t[p].l==t[p].r) &#123;t[p].dat=v; <span class="keyword">return</span>;&#125;</span><br><span class="line">  <span class="keyword">int</span> mid=(t[p].l+t[p].r)/<span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span>(x&lt;=mid) change(p*<span class="number">2</span>,x,v);</span><br><span class="line">    <span class="keyword">else</span> change(p*<span class="number">2</span>+<span class="number">1</span>,x,v);</span><br><span class="line">  t[p].dat=max(t[p*<span class="number">2</span>].dat,t[p*<span class="number">2</span>+<span class="number">1</span>].dat);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="线段树模版2"><a href="#线段树模版2" class="headerlink" title="线段树模版2"></a>线段树模版2</h1><p>[满足区间修改] <a href="https://www.luogu.org/problem/P3372" target="_blank" rel="noopener">P3372 【模板】线段树 1</a></p><p><strong>带延迟标记功能的线段树</strong></p><h2 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h2><ul><li>spread(int p)为延迟标记下移一层</li></ul><p><strong>注意：当该层打上标记后，表示该层内容已经修改，本层以下等待机会再修改。机会来之下一次修改或查询时经过此节点往下递归时。</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t[p].add&gt;<span class="number">0</span>)&#123;</span><br><span class="line">    t[<span class="number">2</span>*p].dat+=t[p].add*(t[<span class="number">2</span>*p].r-t[<span class="number">2</span>*p].l+<span class="number">1</span>);</span><br><span class="line">t[<span class="number">2</span>*p+<span class="number">1</span>].dat+=t[p].add*(t[<span class="number">2</span>*p+<span class="number">1</span>].r-t[<span class="number">2</span>*p+<span class="number">1</span>].l+<span class="number">1</span>);</span><br><span class="line">t[<span class="number">2</span>*p].add+=t[p].add;</span><br><span class="line">t[<span class="number">2</span>*p+<span class="number">1</span>].add+=t[p].add;</span><br><span class="line">t[p].add=<span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="推荐题"><a href="#推荐题" class="headerlink" title="推荐题"></a>推荐题</h1><p>来做题吧！</p><ul><li><a href="https://www.luogu.org/problem/P1531" target="_blank" rel="noopener">I Hate It</a></li><li><a href="https://www.luogu.org/problem/P1774" target="_blank" rel="noopener">最接近神的人</a></li><li><a href="https://www.luogu.org/problem/P1816" target="_blank" rel="noopener">忠诚</a></li><li><a href="https://www.luogu.org/problem/P2590" target="_blank" rel="noopener">树的统计</a></li><li><a href="https://www.luogu.org/problem/P2073" target="_blank" rel="noopener">送花</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RMQ问题&amp;ST表 浅析</title>
      <link href="/2019/02/RMQ%E9%97%AE%E9%A2%98&amp;ST%E8%A1%A8%20%E6%B5%85%E6%9E%90/"/>
      <url>/2019/02/RMQ%E9%97%AE%E9%A2%98&amp;ST%E8%A1%A8%20%E6%B5%85%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是RMQ问题？"><a href="#什么是RMQ问题？" class="headerlink" title="什么是RMQ问题？"></a>什么是RMQ问题？</h1><p>RMQ(Range Min/Max Query):</p><p>对于长度为n的数组A，回答若干询问<code>RMQ(A,i,j)(i,j&lt;=n-1)</code>返回数组A中下标在i,j范围内的最小（大）值，即<strong>RMQ问题是指求区间最值的问题</strong>。</p><p>解决方式：</p><ul><li>朴素算法：每查询一次为O(n)</li><li>ST算法：高效，以O(n log n)的预处理代价，换取O(1)的查询时性能</li></ul><a id="more"></a><h1 id="ST算法"><a href="#ST算法" class="headerlink" title="ST算法"></a>ST算法</h1><p>令：<strong>f[i,j]</strong>代表从第i个数起连续2^j个数中的最大值（因此要用倍增）</p><p>从下图可以看出：<code>f[0][1]=max(f[0][0],f[1][0]), …… f[[0][2]=max(f[0][1],f[2][1]) ……</code></p><p><img src="https://i.loli.net/2019/08/11/JVOWeI9r6CXdEom.png" alt="st表"></p><p> 采用动态规划的思想：显然<code>f[i,j]=max(f[i,j-1],f[i+2^(j-1),j-1])</code></p><p>所以，我们需要建立ST表，也就是上文中的f数组。生成ST表是一次预处理，此后都是O(1)的查询了。</p><h2 id="建立ST表"><a href="#建立ST表" class="headerlink" title="建立ST表"></a>建立ST表</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=n; i++) f[i][<span class="number">0</span>]=a[i]; <span class="comment">//初始化，第0列(j=0)就是a[i]。</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=<span class="number">20</span>; j++)  <span class="comment">//j&lt;20很大啦，够用！2^20=1048576</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i+(<span class="number">1</span>&lt;&lt;j)&lt;=n+<span class="number">1</span>; i++)</span><br><span class="line">f[i][j]=max(f[i][j<span class="number">-1</span>],f[i+(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))][j<span class="number">-1</span>]);</span><br></pre></td></tr></table></figure><p>查询时，只需取在ST表中找2段头尾满足区间范围进行拼凑，有重叠覆盖不影响结果。</p><p>Why?我们来模拟一下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">设A=2，6，4，8，4，8，4，8</span><br><span class="line">求RMQ(A,0,5)[MAX值]=max(RMQ(A,0,3),RMQ(A,2,5))，无论是直接求还是分两段重复的区间求的结果都是8</span><br><span class="line">因为不是运算，所以有重叠部分是可以的哦！</span><br></pre></td></tr></table></figure><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><p>设：范围是 [m,n] ,这个范围不会是刚好2 ^k的长度，我们就用2段区间来拼凑：</p><p>即<code>[m,m+2^k-1]</code>和<code>[n-2^k+1,n]</code> (拼凑后头尾满足[m,n],中间允许重叠)</p><p>因此查询结果即为：<code>RMQ[A,m,n]=max(f[m][k],f[n-(1&lt;&lt;k)+1][k]);</code></p><p>其中2^k&lt;=(n-m+1) 则 <code>k=log2(n-m+1);</code></p><p>举个例子：查询<code>RMQ[A,1,6]=max(f[1][2],f[3][2])</code></p><p><img src="http://t1.aixinxi.net/o_1d3oq2ihs1u8e11l5snpbs21mgoa.png-w.jpg" alt="ST表举例"></p><h3 id="log对数函数"><a href="#log对数函数" class="headerlink" title="log对数函数"></a>log对数函数</h3><p>这里的log来说一下，对数是对求幂的逆运算，正如除法是乘法的倒数</p><p>如果a^x =N（a&gt;0，且a≠1），那么数x叫做以a为底N的对数，记作x=loga N，读作以a为底N的对数，其中a叫做对数的底数，N叫做真数。</p><p>比如说2^5=32，log2 32=5，求的是n次方</p><h1 id="ST表例题"><a href="#ST表例题" class="headerlink" title="ST表例题"></a>ST表例题</h1><h2 id="【模板】ST表-Luogu"><a href="#【模板】ST表-Luogu" class="headerlink" title="【模板】ST表-Luogu"></a><a href="https://www.luogu.org/problemnew/show/P3865" target="_blank" rel="noopener">【模板】ST表-Luogu</a></h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">2000001</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,a[maxn],lg[maxn],f[maxn][<span class="number">25</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="comment">//读入&amp;预处理</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">        f[i][<span class="number">0</span>]=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=<span class="number">20</span>; j++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i+(<span class="number">1</span>&lt;&lt;j)&lt;=n+<span class="number">1</span>;i++)</span><br><span class="line">            f[i][j]=max(f[i][j<span class="number">-1</span>],f[i+(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))][j<span class="number">-1</span>]);</span><br><span class="line">    <span class="comment">//回答每个询问</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> l,r; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;l,&amp;r);</span><br><span class="line">        <span class="keyword">int</span> k=log2(r-l+<span class="number">1</span>),ans=max(f[l][k],f[r-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k]); <span class="comment">//直接使用cmath头文件里的`log2`函数</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="质量检测-Luogu"><a href="#质量检测-Luogu" class="headerlink" title="质量检测-Luogu"></a><a href="https://www.luogu.org/problemnew/show/P2251" target="_blank" rel="noopener">质量检测-Luogu</a></h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//裸的模版题，只不过是没有询问需要自己“手动添加”罢了</span></span><br><span class="line"><span class="comment">//还有一个点就是题目中求的是min值就要将原模版中的所有max改成min才能pass哦</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1000000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> f[N][<span class="number">25</span>],n,m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;f[i][<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>; k&lt;=<span class="number">20</span>; k++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    <span class="keyword">if</span>(i+(<span class="number">1</span>&lt;&lt;k)<span class="number">-1</span>&lt;=n) f[i][k]=min(f[i][k<span class="number">-1</span>],f[i+(<span class="number">1</span>&lt;&lt;(k<span class="number">-1</span>))][k<span class="number">-1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n-m+<span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> s=log2(m);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,min(f[i][s],f[i+m-(<span class="number">1</span>&lt;&lt;s)][s]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RMQ问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>优雅地使用Hexo搭建自己的静态博客3</title>
      <link href="/2019/01/Hexo3/"/>
      <url>/2019/01/Hexo3/</url>
      
        <content type="html"><![CDATA[<h1 id="关联GitHub账号！"><a href="#关联GitHub账号！" class="headerlink" title="关联GitHub账号！"></a>关联GitHub账号！</h1><p>看了之前的教程，你可能会有一个疑问：woc！输入密码真<del>jb</del>烦人！有没有什么方便的方法让我可以在提交时免密码登陆呢？</p><p>为了每一次部署不必一种输入密码，我们可以生成秘钥，然后提交到GitHub，进行关联，那么你下次就不需要再输入密码了。免密提交：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 用你注册GitHub时的邮箱号，进行秘钥生成</span></span><br><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">ssh-keygen -t rsa -C <span class="string">"xxxxxxx@qq.com"</span></span><br><span class="line"><span class="comment"># 系统就会生成一个隐藏文件夹.ssh</span></span><br><span class="line"><span class="built_in">cd</span> .ssh</span><br><span class="line">ls</span><br><span class="line"><span class="comment"># 复制公钥</span></span><br><span class="line">vim id_rsa.pub</span><br></pre></td></tr></table></figure><a id="more"></a><p>在公钥出现后复制下来，切记不要把公钥泄露。大概是这样的：<img src="http://t1.aixinxi.net/o_1d1qtbh4ls97up51h3mecaarda.png-w.jpg" alt="这个"></p><p>来到GitHub，点击头像，进入设置，然后点击SSH and GPG keys，创建新的SSH，将之前复制的公钥黏贴，提交，OK。</p><p><img src="https://upload-images.jianshu.io/upload_images/3478485-9a6fe8e8a47d59dc.png" alt="这个"></p><p><img src="https://upload-images.jianshu.io/upload_images/3478485-92b2d4a66901907b.png" alt="这个"></p><p><img src="https://upload-images.jianshu.io/upload_images/3478485-94a0d1a2f04727f6.png" alt="这个"></p><p>记得，点击的是SSH keys那一行的新建按钮。</p><h1 id="发布文章！"><a href="#发布文章！" class="headerlink" title="发布文章！"></a>发布文章！</h1><h2 id="创建新的文章"><a href="#创建新的文章" class="headerlink" title="创建新的文章"></a>创建新的文章</h2><p>终端进入blog文件夹，输入<code>hexo new 文章名称</code>。执行之后，就会在<code>~/blog/source/_posts/博客名称.md</code>里自动创建“博客名称”.md的markdown文件，然后你就可以输入内容。</p><h3 id="文章front-matter"><a href="#文章front-matter" class="headerlink" title="文章front-matter"></a>文章front-matter</h3><p>.md是markdown的文件后缀名。在第一篇有介绍过用什么软件可以打开它。之后，你可以看到typora打开的窗口中上方有一个框框，储存的是文章的各种元素。它叫Front-matter，是文件最上方以 <code>---</code> 分隔的区域，用于指定个别文件的变量，举例来说：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hello World</span><br><span class="line">date: 2013/7/13 20:46:25</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>在typora中显示的是一个框框，是因为其主题的设置（美化）。在普通编辑器中看到的就是上面这个样子。</p><p>以下是预先定义的参数，您可在模板中使用这些参数值并加以利用。这里选取一些常用的：</p><table><thead><tr><th>参数</th><th>描述</th><th>默认值</th></tr></thead><tbody><tr><td><code>layout</code></td><td>布局</td><td></td></tr><tr><td><code>title</code></td><td>标题</td><td></td></tr><tr><td><code>date</code></td><td>建立日期</td><td>文件建立日期</td></tr><tr><td><code>updated</code></td><td>更新日期</td><td>文件更新日期</td></tr><tr><td><code>comments</code></td><td>开启文章的评论功能</td><td>true</td></tr><tr><td><code>tags</code></td><td>标签（不适用于分页）</td><td></td></tr><tr><td><code>categories</code></td><td>分类（不适用于分页）</td></tr></tbody></table><h3 id="分类和标签"><a href="#分类和标签" class="headerlink" title="分类和标签"></a>分类和标签</h3><p>只有文章支持分类和标签，您可以在 Front-matter 中设置。在其他系统中，分类和标签听起来很接近，但是在 Hexo 中两者有着明显的差别：分类具有顺序性和层次性，也就是说 <code>Foo, Bar</code> 不等于 <code>Bar, Foo</code>；而标签没有顺序和层次。</p><h2 id="发布博文"><a href="#发布博文" class="headerlink" title="发布博文"></a>发布博文</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>然后去<code>username.github.io</code>查看，如果有你的博文在上面，那么就成功了！</p><h2 id="删除博文"><a href="#删除博文" class="headerlink" title="删除博文"></a>删除博文</h2><p>进入<code>~/blog/source/_posts</code>就可以看到你之前发的所有文章。直接删除文件并更新博客即可。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li><a href="https://www.jianshu.com/p/77db3862595c" target="_blank" rel="noopener">https://www.jianshu.com/p/77db3862595c</a></li></ul><p><em>欢迎提出意见！</em></p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>优雅地使用Hexo搭建自己的静态博客2</title>
      <link href="/2019/01/Hexo2/"/>
      <url>/2019/01/Hexo2/</url>
      
        <content type="html"><![CDATA[<h1 id="继续！"><a href="#继续！" class="headerlink" title="继续！"></a>继续！</h1><p>既然我们已经完成了Hexo的安装，那么就是开始使用了。请确保以下步骤在你正确安装完Hexo之后进行。</p><a id="more"></a><h3 id="创建一个blog文件夹"><a href="#创建一个blog文件夹" class="headerlink" title="创建一个blog文件夹"></a>创建一个blog文件夹</h3><p>打开终端，输入<code>mkdir blog</code>。这里的blog可以是你想要的名字，这个文件夹将会作为你今后的Hexo博客的根目录。你的主题设置、博客文章等都会保存在这里。</p><p>使用<code>cd blog</code>进入目录。记住这个代码，这将是你以后的常用指令（在你执行Hexo来更新、部署你的博客时，<em>需要进入你的博客文件夹操作</em>，否则会报错）。</p><h3 id="开启本地服务"><a href="#开启本地服务" class="headerlink" title="开启本地服务"></a>开启本地服务</h3><p>既然配置完了Hexo，我们就可以开启本地服务了。进入文件夹，输入<code>hexo s</code>开启本地服务。接下来，你可以看到<img src="http://t1.aixinxi.net/o_1d1nvmghl1u7510cua0mtto7ria.png-w.jpg" alt="这个"></p><p>把网址复制下来，输入到浏览器里打开，就可以看到类似于这样子的界面：<img src="https://upload-images.jianshu.io/upload_images/3478485-7c18ba82bb6dd688.png" alt="这个"></p><p>到这里说明你的环境以及没有问题了，成功了搭建起了博客框架。</p><p>注：<code>hexo s</code>这个命令其实挺有用的，可以看到编辑后博客的样子（不是网页！别人如果登陆这个本地网址也看不到你的博客），但用时比发布时间短，可以快速知道blog的样子。</p><h1 id="GitHub-Page关联"><a href="#GitHub-Page关联" class="headerlink" title="GitHub Page关联"></a>GitHub Page关联</h1><p><a href="https://baike.baidu.com/item/github/10145341?fr=aladdin" target="_blank" rel="noopener">GitHub简介</a>，就是一个代码托管平台。有个功能叫做GitHub Page，用于静态页面的项目托管，Hexo博客一般会先选择将它托管在这里。先来注册一下：<a href="https://github.com/" target="_blank" rel="noopener">GitHub官网</a>。可以看到这样：<img src="http://t1.aixinxi.net/o_1d1o0umlo7104n55qv143o1dpfa.png-w.jpg" alt="这个"></p><p>输入username，注意一下，这里的名字将关联到你博客网址（GitHub版）的名称，慎重！<u>我原来把residual打错了于是又折腾了一个23333！</u>第二行输入邮箱、第三行输入密码。密码只输一次，小心一点。</p><h3 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h3><p>由于GitHub网站是纯英文的，没有翻译有些人可能看得难受。在这里推荐使用Chrome谷歌浏览器。它在浏览纯英文网页时会有一个网页翻译的功能，方便理解。<img src="http://t1.aixinxi.net/o_1d1o34b8e1ctu1upi13eldpa1l6ba.png-w.jpg" alt="这个"></p><h2 id="建立仓库"><a href="#建立仓库" class="headerlink" title="建立仓库"></a>建立仓库</h2><p>注册完后显示的界面就是你的仪表盘。右上角找到新建图标，点击<em>New repository</em>，如图：<img src="https://upload-images.jianshu.io/upload_images/3478485-918befac816ff5d6.png" alt="这个"></p><p>跳出该界面：<img src="https://upload-images.jianshu.io/upload_images/3478485-d451ae9bb81c6d0e.png" alt="这个"></p><blockquote><p> 这里的owner就是你当前的用户名。创建仓库的名字必须为<code>username.github.io</code>（就是那个name的输入框里填写的内容），我的用户名为ResidualNight，因此我创建的仓库名就是<strong>ResidualNight.github.io</strong>，这是很关键的一点，很重要。输入名字后，直接点最下面绿色的按钮，创建新仓库。<strong>切记用户名的正确与否</strong>！</p></blockquote><h2 id="关联博客"><a href="#关联博客" class="headerlink" title="关联博客"></a>关联博客</h2><p>打开blog根目录。这里有一个文件叫做”_config.yml”，打开。如果有好的编辑器可以用，如：visual studio code等，正常情况下直接用文本编辑可以打开。<img src="http://t1.aixinxi.net/o_1d1o3mcc21oji1boei4uq2n1p5na.png-w.jpg" alt="这个"></p><p>找到如图所示的代码段，输入和我一样的内容。至于我的ResidualNight，替换成你自己的GitHub用户名。然后保存文件。</p><p>回到终端进入目录，输入命令（“#”为注释内容，不用输）：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 产生静态网页</span></span><br><span class="line">hexo g</span><br><span class="line"><span class="comment"># 部署到GitHub page上</span></span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>以后，我们在更新文章、主题设置时都会运用到这两个命令，注意顺序，先g后d。在<code>hexo d</code>后，会要求输入GitHub的账户名称和密码。</p><p><code>hexo g</code>正常：<img src="http://t1.aixinxi.net/o_1d1o9q97r1a5dtue1p8u1m971878a.png-w.jpg" alt="hexo g"></p><p><code>hexo d</code>输入用户名&amp;密码图示：<img src="http://t1.aixinxi.net/o_1d1o9udq0ih9eai1jf01s2j99ia.png-w.jpg" alt="hexo d">这里注意一下，输入密码时一般是不显示你的密码的。</p><p>部署完了网页，就可以登陆网页了！浏览器输入username.github.io，就可以看到你的博客了。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li><a href="https://www.jianshu.com/p/77db3862595c" target="_blank" rel="noopener">https://www.jianshu.com/p/77db3862595c</a></li><li>想知道根目录文件夹里的文件做什么的看这里：<a href="https://hexo.io/zh-cn/docs/setup" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/setup</a></li></ul><p><em>欢迎提出意见！</em></p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>优雅地使用Hexo搭建自己的静态博客1</title>
      <link href="/2019/01/Hexo1/"/>
      <url>/2019/01/Hexo1/</url>
      
        <content type="html"><![CDATA[<h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><p>如题，这个静态博客就是使用hexo制作的。如果你对此有兴趣，有探究精神（<del>又闲着没有事</del>），那么你可以来尝试制作一下你的blog！在这里，我会尽量用通俗一些的语言来阐述这一过程，那么我们开始吧！</p><p>如果你是一个大佬，这一章的内容自行跳过。<del>是大佬也不会来看我的博客了233</del></p><a id="more"></a><p>这里开始科普一下我们所需要的东西：</p><h2 id="Hexo是个什么玩意儿？"><a href="#Hexo是个什么玩意儿？" class="headerlink" title="Hexo是个什么玩意儿？"></a>Hexo是个什么玩意儿？</h2><p>看到标题，你可能会有些蒙圈：hexo是个什么鬼？这个很简单，你可以请教一下baidu以及<a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">官网</a>。稍稍引用一下：</p><blockquote><p>hexo 正常来说，不需要部署到我们的服务器上。我们的服务器上保存的，其实是基于在hexo通过<u>markdown</u>编写的文章，然后hexo帮我们生成静态的html页面，然后，将生成的html上传到我们的服务器，这样就有了我们所看到的博客界面。简而言之：hexo是个<em>静态页面生成、上传的工具</em>。</p></blockquote><p>简单来说，就是配置好了hexo后，你只用写出博客网站的<u>markdown</u>代码（保存在一定的地方），就可以让hexo帮助你制作出含有你的博文的网页。当然你也可以自己定制网页的自定义，比如说下载他人的主题，并按自己的想法进行改进。</p><p>许多大佬、或是萌新们都会使用hexo搭建blog，毕竟人家简单、自由度还高嘛。</p><h2 id="Markdown又是个什么玩意儿？"><a href="#Markdown又是个什么玩意儿？" class="headerlink" title="Markdown又是个什么玩意儿？"></a>Markdown又是个什么玩意儿？</h2><p>这个真的就只有baidu可以帮助你了：<a href="https://baike.baidu.com/item/markdown/3245829?fr=aladdin" target="_blank" rel="noopener">Markdown强行科普</a>。其实就是在正常打字时加上一些特殊的符号让文章能够层次分明，是一种在博客、OI（编程界）里十分流行的文本语言，hexo用的就是这种流行的语言。至于具体用法，在上文的链接中有说明，如果可以，我会放到“文章”那一部分那里写～</p><p>这里比较推荐的markdown书写工具是这个：<a href="https://www.typora.io/" target="_blank" rel="noopener">typora</a>，简洁好用，支持hexo格式。</p><h2 id="‘终端’科普"><a href="#‘终端’科普" class="headerlink" title="‘终端’科普"></a>‘终端’科普</h2><p>现在有两个主流电脑操作系统：</p><ul><li>mac</li><li>windows</li></ul><p>Mac的终端名称是终端（Terminal），打开它很简单，进入启动台查找或是使用聚焦搜索查找；</p><p>Windows的终端名称一般叫做cmd，在“开始”菜单栏里找到它或是使用“运行”这个应用输入cmd（实在不会的找baidu）</p><p>打开了吗？就是你眼前这个黑黑的东西，最上方有一串白字，代表你当前的启动盘。具体怎么用等会说。</p><h1 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h1><p>参考官网<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">文档</a>：</p><h2 id="安装Hexo的支持"><a href="#安装Hexo的支持" class="headerlink" title="安装Hexo的支持"></a>安装Hexo的支持</h2><p>Hexo的安装需要两个软件的支持，它们分别是：</p><ul><li><a href="http://nodejs.org/" target="_blank" rel="noopener">Node.js</a></li><li><a href="http://git-scm.com/" target="_blank" rel="noopener">Git</a></li></ul><h3 id="git安装"><a href="#git安装" class="headerlink" title="git安装"></a>git安装</h3><p>windows：下载并安装 <a href="https://git-scm.com/download/win" target="_blank" rel="noopener">git</a>（嫌下载速度慢的看这个<a href="https://github.com/waylau/git-for-win" target="_blank" rel="noopener">git国内下载站</a>注意看清楚版本号和windows版本，看不懂还是使用龟速下载比较好）</p><p>mac：在终端输入<code>brew install git</code>或下载 <a href="http://sourceforge.net/projects/git-osx-installer/" target="_blank" rel="noopener">安装程序</a> 安装。</p><h3 id="Node-js安装"><a href="#Node-js安装" class="headerlink" title="Node.js安装"></a>Node.js安装</h3><p>在这里用命令行安装可能讲的不太清楚。<a href="https://nodejs.org/en/" target="_blank" rel="noopener">下载地址</a>，下载安装。</p><p>对于Windows用户的建议：可以使用<strong>Git Bash</strong>，这是git for windows自带的一组程序，提供了Linux风格的shell。打开它的方法很简单，在<strong>桌面任意位置单击右键</strong>，选择“Git Bash Here”即可。由于Hexo的<strong>很多操作都涉及到命令行</strong>，您可以考虑始终使用<strong>Git Bash</strong>来进行操作。</p><h2 id="安装Hexo！"><a href="#安装Hexo！" class="headerlink" title="安装Hexo！"></a>安装Hexo！</h2><p>在完成上述安装后，安装hexo：</p><p>在终端里输入：<code>npm install -g hexo-cli</code></p><p>mac用户可能会报错。这里使用<code>sudo npm install -g hexo-cli</code>安装。</p><h1 id="一些建议"><a href="#一些建议" class="headerlink" title="一些建议"></a>一些建议</h1><ul><li>Windows中：终端中<code>Ctrl + C</code>是stop的快捷键，不要使用<code>Ctrl + C</code>或<code>Ctrl + V</code>的快捷键，用右键单击标题栏。</li><li>出现问题找官网和百度</li><li>也可以去找一些其他人写的教程，我写的是通俗版的，但归根到底都是根据别人的教程<del>不然我怎么搭建的博客233</del></li><li>哦对官网上也有b站的视频可以学习：<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/</a></li></ul><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li><a href="https://www.jianshu.com/p/77db3862595c" target="_blank" rel="noopener">https://www.jianshu.com/p/77db3862595c</a></li><li><a href="https://www.jianshu.com/p/a2fe56d11c4f" target="_blank" rel="noopener">https://www.jianshu.com/p/a2fe56d11c4f</a></li><li><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/</a></li></ul><p><em>欢迎提出意见！</em></p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Welcome</title>
      <link href="/2019/01/Welcome/"/>
      <url>/2019/01/Welcome/</url>
      
        <content type="html"><![CDATA[<h1 id="Hello"><a href="#Hello" class="headerlink" title="Hello!"></a>Hello!</h1><p><strong>很高兴认识你！</strong></p><p>这里是<em>Residual Night</em>的第一个个人博客，基于<a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo</a>&amp;&amp;<a href="https://github.com/" target="_blank" rel="noopener">github</a>搭建的静态博客。</p><a id="more"></a><h1 id="这是什么？"><a href="#这是什么？" class="headerlink" title="这是什么？"></a>这是什么？</h1><p>在这个blog上，主要会发表一些我的一些idea和编程笔记。至于编程，我只是一个刚接触<strong>c++</strong>的普及组+选手而已（初中苣蒻，勿喷）。但我坚信，我会在OI的道路上砥砺前行的。</p><h1 id="长风破浪会有时，直挂云帆济沧海。"><a href="#长风破浪会有时，直挂云帆济沧海。" class="headerlink" title="长风破浪会有时，直挂云帆济沧海。"></a>长风破浪会有时，直挂云帆济沧海。</h1><p>不管有没有人看得到，不管我会不会在这个博客上坚持下去，但这里总是一个梦想开始的地方。</p><h1 id="test"><a href="#test" class="headerlink" title="test"></a>test</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ios::sync_with_stdio();</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Hello World!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 个人生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> personal </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
