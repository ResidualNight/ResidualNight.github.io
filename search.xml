<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CSP-S第二轮tips</title>
      <link href="/2019/10/01/2019CSP-S%E5%A4%8D%E8%B5%9Btips/"/>
      <url>/2019/10/01/2019CSP-S%E5%A4%8D%E8%B5%9Btips/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="动归"><a href="#动归" class="headerlink" title="动归"></a>动归</h1><h2 id="最长不降子序列"><a href="#最长不降子序列" class="headerlink" title="最长不降子序列"></a>最长不降子序列</h2><p><a href="https://www.luogu.org/problem/P1481" target="_blank" rel="noopener">P1481</a></p><blockquote><p><code>strstr(s1,s2)</code>判断<code>s2</code>是否<code>s1</code>的子串，没有找到返回<strong>NULL</strong>，找到则返回子串第一个字符的地址</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2000</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> n,f[N],ans=<span class="number">-999</span>;</span><br><span class="line"><span class="keyword">char</span> s[N][N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;s[i]; f[i]=<span class="number">1</span>; <span class="comment">//初始化</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=i<span class="number">-1</span>; k&gt;=<span class="number">1</span>; k--)</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strstr</span>(s[i],s[k])==s[i]) f[i]=max(f[k]+<span class="number">1</span>,f[i]); <span class="comment">//DP</span></span><br><span class="line">ans=max(ans,f[i]); <span class="comment">//更新</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>,<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最长上升子序列-LIS"><a href="#最长上升子序列-LIS" class="headerlink" title="最长上升子序列(LIS)"></a>最长上升子序列(<em>LIS</em>)</h2><p>例子：</p><p>有6个数，分别是： <code>1 7 6 2 3 4</code>求最长上升子序列。</p><blockquote><p>最长上升子序列的元素不一定相邻</p><p>最长上升子序列一定是原序列的子集</p></blockquote><p>所以这个例子中的<em>LIS</em>就是：1 2 3 4，共4个<br>$$<br>n^2<br>$$</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x) <span class="keyword">return</span>;</span><br><span class="line">    print(from[x]);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;a[x]&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//迭代输出</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">        dp[i]=<span class="number">1</span>; from[i]=<span class="number">0</span>; <span class="comment">//from:前驱记录</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>; k&lt;i; k++)</span><br><span class="line">            <span class="keyword">if</span>(a[k]&lt;d[i] &amp;&amp; dp[i]&lt;dp[k]+<span class="number">1</span>) dp[i]=dp[k]+<span class="number">1</span>,from[i]=k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans=dp[<span class="number">1</span>],p=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n ;i++) <span class="keyword">if</span>(ans&lt;dp[i]) ans=dp[i],p=i;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    print(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最长公共子序列-LCS"><a href="#最长公共子序列-LCS" class="headerlink" title="最长公共子序列(LCS)"></a>最长公共子序列(<em>LCS</em>)</h2><p><a href="https://www.luogu.org/problem/P1439" target="_blank" rel="noopener">P1439</a></p><p>使用<code>dp[i][j]</code>表示第一个串的前<code>i</code>位，第二个串的前<code>j</code>位的LCS长度</p><p>则状态转移方程为：</p><p><strong>1:</strong> 如果有新的公共元素(<code>A1[i]==A2[j]</code>)<br>$$<br>dp[i][j]=max(dp[i][j],dp[i-1][j-1]+1);<br>$$<br><strong>2:</strong> 如果无法更新公共元素<br>$$<br>dp[i][j]=max(dp[i-1][j],dp[i][j-1]);<br>$$</p><h3 id="朴实做法-n-2"><a href="#朴实做法-n-2" class="headerlink" title="朴实做法 (n^2)"></a>朴实做法 (n^2)</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) <span class="built_in">cin</span>&gt;&gt;a1[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; i++) <span class="built_in">cin</span>&gt;&gt;a2[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>; k&lt;=m; k++)&#123;</span><br><span class="line">        dp[i][k]=max(dp[i<span class="number">-1</span>][k],dp[i][k<span class="number">-1</span>]);</span><br><span class="line">        <span class="keyword">if</span>(a1[i]==a2[k]) dp[i][k]=max(dp[i][k],dp[i<span class="number">-1</span>][k<span class="number">-1</span>]+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">cout</span>&lt;&lt;dp[n][m]&lt;&lt;<span class="built_in">endl</span>,<span class="number">0</span>;</span><br></pre></td></tr></table></figure><p><del>实则爆零</del></p><h3 id="AC"><a href="#AC" class="headerlink" title="AC"></a>AC</h3><p> 以第一个串为标准，用第二个串来匹配第一个串，看能匹配多少 </p><p> 把第一个串<strong>离散化</strong>后的数组是满足上升，反过来，满足上升的也就是满足原串的排列顺序的 </p><p> 求一个<strong>最长不下降序列</strong></p><blockquote><p><code>lower_bound(begin,end,num)</code>：从数组的<code>begin</code>位置到<code>end-1</code>位置二分查找第一个大于或等于<code>num</code>的数字，找到返回该数字的地址，不存在则返回end。</p><p>通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。 </p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100000</span>+<span class="number">1000</span>;</span><br><span class="line"><span class="keyword">int</span> a[N],b[N],ma[N],ans=<span class="number">0</span>,f[N],p[N],n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">ma[a[i]]=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) <span class="built_in">cin</span>&gt;&gt;b[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(ma[b[i]]&gt;p[ans])&#123;</span><br><span class="line">p[++ans]=ma[b[i]];</span><br><span class="line">f[i]=ans; <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> k=lower_bound(p+<span class="number">1</span>,p+ans+<span class="number">1</span>,ma[b[i]])-p;</span><br><span class="line">p[k]=ma[b[i]];</span><br><span class="line">f[i]=k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>,<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h2><h3 id="P1417"><a href="#P1417" class="headerlink" title="P1417"></a><a href="https://www.luogu.org/problem/P1417" target="_blank" rel="noopener">P1417</a></h3><blockquote><p>平常做01背包的题时，由于i的价值永远是不变的，所以i讨论的顺序对结果不影响</p><p>但是这道题中，如果你先讨论了1号点，再讨论第二点，第二点的价值会减小，反之一号点会减小，这两个哪个更优是不确定的，所以如果你先讨论1号点就会错</p><p>由此，需要按优先度对所有点进行排序</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100000</span>+<span class="number">1000</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data</span>&#123;</span></span><br><span class="line">ll a,b,c;</span><br><span class="line">&#125;d[N];</span><br><span class="line">ll T,n,f[N],ans=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(data x,data y)</span></span>&#123;<span class="keyword">return</span> x.c*y.b&lt;y.c*x.b;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;T&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(ll i=<span class="number">1</span>; i&lt;=n; i++) <span class="built_in">cin</span>&gt;&gt;d[i].a;</span><br><span class="line"><span class="keyword">for</span>(ll i=<span class="number">1</span>; i&lt;=n; i++) <span class="built_in">cin</span>&gt;&gt;d[i].b;</span><br><span class="line"><span class="keyword">for</span>(ll i=<span class="number">1</span>; i&lt;=n; i++) <span class="built_in">cin</span>&gt;&gt;d[i].c;</span><br><span class="line">sort(d+<span class="number">1</span>,d+n+<span class="number">1</span>,cmp);</span><br><span class="line"><span class="keyword">for</span>(ll i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line"><span class="keyword">for</span>(ll k=T; k-d[i].c&gt;=<span class="number">0</span>; k--)</span><br><span class="line">f[k]=max(f[k],f[k-d[i].c]+d[i].a-k*d[i].b);</span><br><span class="line"><span class="keyword">for</span>(ll i=<span class="number">1</span>; i&lt;=T; i++) ans=max(ans,f[i]);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>,<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="P1510"><a href="#P1510" class="headerlink" title="P1510"></a><a href="https://www.luogu.org/problem/P1510" target="_blank" rel="noopener">P1510</a></h3><h1 id="CSP-S-problem-plan"><a href="#CSP-S-problem-plan" class="headerlink" title="CSP-S problem plan"></a>CSP-S problem plan</h1><blockquote><p>1.二分 (洛谷 1577)</p><p>2.快速幂 （洛谷 1226）</p><p>3.搜索<br>1&gt;.深搜  （洛谷2919）<br>2&gt;.广搜  （洛谷1506）<br>3&gt;.种子染色（洛谷1451）<br>3&gt;.记忆化搜索  （洛谷1434）</p><p>4.动规<br>1&gt;.最长不降子序列：1481<br>2&gt;.最长公共子序列：1439<br>3&gt;.01背包：1417 1510 1855<br>4&gt;.完全背包：1616<br>5&gt;.多重背包：1776<br>6&gt;.区间动规：3146</p><p>5.图论<br>1&gt;.最短路<br>dij  （堆优化）1629<br>floyed  1364<br>SPFA  1529<br>最短路计数 1144 </p><p>2&gt;.最小生成树<br>prim：1194<br>克鲁斯卡尔：1195</p><p>3&gt; targen强连通分量  1656</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> C++学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>卡特兰数 浅析</title>
      <link href="/2019/09/03/%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0/"/>
      <url>/2019/09/03/%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p><strong>卡特兰数</strong>又称<strong>卡塔兰数</strong> <em>(Catalan Number)</em>,是组合数学中一个经常出现在各种计数问题中的数列。其前几项为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">5</span><br><span class="line">14</span><br><span class="line">42</span><br><span class="line">132</span><br><span class="line">429</span><br><span class="line">1430</span><br><span class="line">4862</span><br><span class="line">16796</span><br><span class="line">58786</span><br><span class="line">208012</span><br><span class="line">742900</span><br><span class="line">...</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h1><p>求卡特兰数列的第n项</p><p><strong>公式1</strong><br>$$<br>f(n)=\sum_{i=0}^{n-1}f(i)\times f(n-i-1)<br>$$</p><p><strong>公式2</strong><br>$$<br>f(n)=\frac {f(n-1)\times(f\times n-2)}{n+1}<br>$$</p><p><strong>公式3</strong><br>$$<br>f(n)=\frac{C_{2n}^{n}}{n+1}<br>$$</p><p><strong>公式4</strong><br>$$<br>f(n)=C_{2n}^{n}-C_{2n}^{n-1}<br>$$</p><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>卡特兰数经常出现在OI以及ACM中，在生活中也有广泛的应用。</p><h2 id="进出栈问题"><a href="#进出栈问题" class="headerlink" title="进出栈问题"></a>进出栈问题</h2><p><strong>栈是一种先进后出（FILO,First In Last Out）的数据结构</strong></p><p>那么一个足够大的栈的进栈序列为1,2,3,⋯,n时有多少个不同的出栈序列？</p><blockquote><p>假设k为最后一个出栈的元素。比k早进栈且早出栈的有k-1个数，一共有<strong>f(k-1)</strong>种方案。比k晚进栈且早出栈的有n-k个数，一共有<strong>f(n-k)</strong>种方案。所以一共有<strong>f(k-1)*f(n-k)</strong>种方案。当k取不同值时，产生的出栈序列是互相独立的，因此可累加。因为k的取值范围是1~n，所以结果为<br>$$<br>f(n)=f(0)\times f(n-1)+f(1)\times f(n-2)+…+f(n-1)\times f(0)<br>$$<br>注意：n&gt;=2</p></blockquote><p>例题：<a href="https://www.luogu.org/problem/P1044" target="_blank" rel="noopener">P1044 栈</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> f[N];</span><br><span class="line">f[<span class="number">0</span>]=f[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=n; i++)</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;i; k++)</span><br><span class="line">      f[i]+=f[k]*f[i-k+<span class="number">1</span>];</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;f[n]&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><h2 id="二叉树的计数"><a href="#二叉树的计数" class="headerlink" title="二叉树的计数"></a>二叉树的计数</h2><p>已知一颗二叉树有n个结点，问：该二叉树能组成多少种不同的形态?</p><blockquote><p>假设如果采用中序遍历的话，根结点第k个被访问到，则根结点的左子树有<code>k-1</code>个点、根结点的右指数有<code>n-k</code>个点。k的取值范围为1到n。明显的卡特兰数。</p></blockquote><h2 id="AB排列问题"><a href="#AB排列问题" class="headerlink" title="AB排列问题"></a>AB排列问题</h2><p>有n个A和n个B排成一排，从第1个位置开始到任何位置，B的个数不能超过A的个数，这样的排列有多少种？</p><p>如：</p><p>n=1: AB</p><p>n=2: AABB ABAB</p><p>n=3: AAABBB AABABB AABBAB ABAABB ABABA</p><blockquote><p>在n*n的格子中，只在下三角行走，每次横或竖走一格，有多少种走法？</p><p>向右走相当于进栈(A)，向左走相当于出栈(B)，本质就是n个数出栈次序的问题。</p></blockquote><p><img src="http://images.cppblog.com/cppblog_com/miyu/450px-Catalan_number_4x4_grid_example.svg.png" alt="AB排列问题"></p><h2 id="乘法加括号"><a href="#乘法加括号" class="headerlink" title="乘法加括号"></a>乘法加括号</h2><p><strong>NOI 1988</strong></p><p>对于连乘：<br>$$<br>a[0]\times a[1]\times a[2]\times …\times a[n]<br>$$<br>加了括号后可以改变它的运算顺序，问有多少种不同的运算顺序？</p><blockquote><p>将其表示成一颗二叉树，把<code>*</code>逐个作为根，得到卡特兰数。</p></blockquote><h1 id="参考文献-amp-网址"><a href="#参考文献-amp-网址" class="headerlink" title="参考文献&amp;网址"></a>参考文献&amp;网址</h1><ul><li>&lt;信息学奥赛之数学一本通&gt;林厚从 主编, 东南大学出版社</li><li><a href="https://blog.csdn.net/wookaikaiko/article/details/81105031" target="_blank" rel="noopener">https://blog.csdn.net/wookaikaiko/article/details/81105031</a></li><li><a href="https://www.luogu.org/blog/Ning-H/solution-p1044" target="_blank" rel="noopener">https://www.luogu.org/blog/Ning-H/solution-p1044</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高精度运算</title>
      <link href="/2019/08/13/%E9%AB%98%E7%B2%BE%E5%BA%A6%E8%BF%90%E7%AE%97/"/>
      <url>/2019/08/13/%E9%AB%98%E7%B2%BE%E5%BA%A6%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<p>必要的高精度运算。</p><a id="more"></a><h1 id="高精加"><a href="#高精加" class="headerlink" title="高精加"></a>高精加</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i=<span class="number">1</span>,x=<span class="number">0</span>; <span class="built_in">memset</span>(c,<span class="number">0</span>,<span class="keyword">sizeof</span>(c));</span><br><span class="line"><span class="keyword">while</span>(i&lt;=la || i&lt;=lb) <span class="comment">//只要i小于a或b的长度就的循环</span></span><br><span class="line">&#123;</span><br><span class="line">  c[i]+=a[i]+b[i]; <span class="comment">//第i位加，注意含进位，给c数组</span></span><br><span class="line">    c[i+<span class="number">1</span>]+=c[i]/<span class="number">10</span>; <span class="comment">//取该位置的进位</span></span><br><span class="line">    c[i]%=<span class="number">10</span>; <span class="comment">//留下没有进位的部分</span></span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(c[i]&gt;<span class="number">0</span>) lc=i;</span><br><span class="line"><span class="keyword">else</span> lc=i<span class="number">-1</span>;       <span class="comment">//lc记录结果的长度</span></span><br></pre></td></tr></table></figure><h1 id="高精减"><a href="#高精减" class="headerlink" title="高精减"></a>高精减</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i=<span class="number">1</span>; <span class="built_in">memset</span>(c,<span class="number">0</span>,<span class="keyword">sizeof</span>(c));</span><br><span class="line"><span class="keyword">while</span>(i&lt;=la)&#123;</span><br><span class="line">  <span class="keyword">if</span>(a[i]&lt;b[i]) a[i]+=<span class="number">10</span>,a[i+<span class="number">1</span>]--;</span><br><span class="line">    c[i]=a[i]-b[i];</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br><span class="line">lc=i;</span><br><span class="line"><span class="keyword">while</span>(lc&gt;<span class="number">1</span> &amp;&amp; c[lc]==<span class="number">0</span>) lc--;</span><br></pre></td></tr></table></figure><h1 id="高精乘"><a href="#高精乘" class="headerlink" title="高精乘"></a>高精乘</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">memset</span>(c,<span class="number">0</span>,<span class="keyword">sizeof</span>(c));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=lb; i++)&#123;</span><br><span class="line">    x=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>; k&lt;=la; k++)&#123;</span><br><span class="line">    c[i+k<span class="number">-1</span>]+=b[i]*a[k]+x;</span><br><span class="line">      x=c[i+k<span class="number">-1</span>]/<span class="number">10</span>;</span><br><span class="line">      c[i+k<span class="number">-1</span>]%=<span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  c[i+la]=x;</span><br><span class="line">&#125;</span><br><span class="line">lc=la+lb;</span><br><span class="line"><span class="keyword">while</span>(c[lc]==<span class="number">0</span> &amp;&amp; lc&gt;<span class="number">1</span>) lc--;</span><br></pre></td></tr></table></figure><h1 id="单精乘高精"><a href="#单精乘高精" class="headerlink" title="单精乘高精"></a>单精乘高精</h1><p>「n!」</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">c[<span class="number">1</span>]=l=<span class="number">1</span>,x=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">  x=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>; k&lt;=l; k++)&#123;</span><br><span class="line">    c[k]=c[k]*i+x;x=c[j]/<span class="number">10</span>;</span><br><span class="line">      x=c[j]/<span class="number">10</span>;</span><br><span class="line">        c[j]%=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(x&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        l++;</span><br><span class="line">        c[l]=x%<span class="number">10</span>;</span><br><span class="line">        x/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i:=l;i&gt;=<span class="number">1</span>;i--) <span class="built_in">cout</span>&lt;&lt;c[i];</span><br></pre></td></tr></table></figure><h1 id="高精除单精"><a href="#高精除单精" class="headerlink" title="高精除单精"></a>高精除单精</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=la; i++)&#123;</span><br><span class="line">    c[i]=(x*<span class="number">10</span>+a[i])/b;</span><br><span class="line">    x=(x*<span class="number">10</span>+a[i])%b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> p=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(c[p]==<span class="number">0</span> &amp;&amp; p&lt;la) p++;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=p; i&lt;=la; i++) <span class="built_in">cout</span>&lt;&lt;c[i];</span><br><span class="line"><span class="comment">//最后的x为余数</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高精 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>是基础算法！</title>
      <link href="/2019/08/11/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
      <url>/2019/08/11/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>一些基础的算法。</p><a id="more"></a><h1 id="最大公约数gcd"><a href="#最大公约数gcd" class="headerlink" title="最大公约数gcd"></a>最大公约数gcd</h1><p><del>开挂法</del>：<code>__gcd(a,b);</code><del>STL大法好！！！(震耳欲聋)</del></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(b==<span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">  <span class="keyword">return</span> gcd(b,a%b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最大公约数与最小公倍数的关系<code>gcd(a,b)*lcm(a,b)=ab</code></p><h1 id="素数判断"><a href="#素数判断" class="headerlink" title="素数判断"></a>素数判断</h1><h2 id="简单法"><a href="#简单法" class="headerlink" title="简单法"></a>简单法</h2><p>暴力<del>超时见祖宗</del></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">pand</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="comment">//x&gt;=3</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i*i&lt;=x; i++)</span><br><span class="line">  <span class="keyword">if</span>(x%i==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="筛法"><a href="#筛法" class="headerlink" title="筛法"></a>筛法</h2><blockquote><p><strong><1></1></strong>取最小的素数2，筛去它的所有倍数</p><p><strong><2></2></strong>取未被筛最小的数（一定是素数），再筛去它的所有倍数</p><p><strong><3></3></strong>重复<strong><2></2></strong>直至全部都是素数（取最小数只需到 sqrt(n) ）</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> isprime[N]</span><br><span class="line"><span class="keyword">int</span> n,ans=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(isprime,<span class="number">1</span>,<span class="keyword">sizeof</span>(isprime));</span><br><span class="line">  <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">  isprime[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=<span class="built_in">sqrt</span>(n); i++) <span class="comment">//生成</span></span><br><span class="line">    <span class="keyword">if</span>(isprime[i]) <span class="keyword">for</span>(<span class="keyword">int</span> k=i*i; k&lt;=n; k+=i) isprime[k]=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=n; i++) <span class="comment">//输出</span></span><br><span class="line">      <span class="keyword">if</span>(isprime[i]) &#123;ans++; <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">" "</span>;&#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><p><img src="https://i.loli.net/2019/08/11/LDANzYjbrBI1u5v.png" alt="排序"></p><p><img src="https://i.loli.net/2019/08/12/PhaSnrtJA5me6ip.png" alt="排序"></p><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n<span class="number">-1</span>; i++)</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;=n; j++)</span><br><span class="line">    <span class="keyword">if</span>(a[i]&gt;a[j]) t=a[j],a[j]=a[i],a[i]=t;</span><br></pre></td></tr></table></figure><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p><em>对于接近有序的数列，加标记可以缩短排序时间</em></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>; i&gt;=<span class="number">1</span>; i--)&#123;</span><br><span class="line">  <span class="keyword">int</span> p=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>; k&lt;=i; k++)</span><br><span class="line">      <span class="keyword">if</span>(d[k]&gt;d[k+<span class="number">1</span>]) swap(d[k+<span class="number">1</span>],d[k]),p=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(!p) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=n; i++)&#123;</span><br><span class="line">  <span class="keyword">int</span> p=a[i];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> k=i; k&gt;<span class="number">1</span> &amp;&amp; p&lt;a[k<span class="number">-1</span>]; k--) a[k]=a[k<span class="number">-1</span>];</span><br><span class="line">  a[k]=p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h2><p><code>sort(a+1,a+n+1,cmp);</code><del>STL大法好！！！(再次破音)</del></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//手写快排</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> x=l,y=r,mid=a[(l+r)/<span class="number">2</span>]; <span class="comment">//mid:取一个数</span></span><br><span class="line">  <span class="keyword">do</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(a[i]&lt;mid) x++; <span class="comment">//左边起比mid小的数不动，x停在不比mid小的位子</span></span><br><span class="line">      <span class="keyword">while</span>(mid&lt;a[y]) y--; <span class="comment">//右边起比mid大的数不动，y停在不比mid大的位子</span></span><br><span class="line">      <span class="keyword">if</span>(x&lt;=y) swap(a[x],a[y]),x++,y--; <span class="comment">//如果x与y不交叉，交换x与y的数，x与y各再跳一步</span></span><br><span class="line">  &#125;<span class="keyword">while</span>(x&lt;=y); <span class="comment">//直至x与y交叉；mid已经在交叉的位置了</span></span><br><span class="line">  <span class="keyword">if</span>(l&lt;y) qsort(l,y); <span class="comment">//左边还有数(l&lt;y),递归</span></span><br><span class="line">   <span class="keyword">if</span>(x&lt;r) qsort(x,r); <span class="comment">//右边还有数(x&lt;r),递归</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>把两个已经有序的序列，归并成一个有序的序列</p><p><strong><u>归并排序不会像快排那样蜕化为o(n2),最好和最坏的情况都是o(nlog2n)</u></strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l!=r)&#123;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    merge_sort(l,mid);</span><br><span class="line">    merge_sort(mid+<span class="number">1</span>,r);</span><br><span class="line">      merge(l,mid,r);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> q,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> tt=p,tl=p,tr=q+<span class="number">1</span>; <span class="comment">//tt是tmp的指针，tl和tr是两个待合并有序序列的指针</span></span><br><span class="line">  <span class="keyword">while</span>(tt&lt;=r)&#123;</span><br><span class="line">    <span class="keyword">if</span>(tl&lt;=q &amp;&amp; (tr&gt;r || a[tl]&lt;a[tr])) tmp[tt++]=a[tl++];  <span class="comment">//tl还有元素，tr已经没有元素或tr指的元素较大</span></span><br><span class="line">     <span class="keyword">else</span> tmp[tt++]=a[tr++]; <span class="comment">//除上述情况的其他情况</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=p;i&lt;=r;i++) a[i]=tmp[i]; <span class="comment">//在tmp[]合并好后要搬到a[]中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h1><p>a[ ]已经排序</p><h2 id="递归算法"><a href="#递归算法" class="headerlink" title="递归算法"></a>递归算法</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> <span class="comment">//x为要查找的数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(l&gt;r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span>(x==a[mid]) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(x&lt;a[mid]) <span class="keyword">return</span> find(x,l,mid<span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">if</span>(x&gt;a[mid]) <span class="keyword">return</span> find(x,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="非递归算法"><a href="#非递归算法" class="headerlink" title="非递归算法"></a>非递归算法</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">      <span class="keyword">if</span>(x==mid) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span>(x&lt;a[mid]) r=mid<span class="number">-1</span>;</span><br><span class="line">      <span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//输出：ans%p</span></span><br><span class="line">ans=<span class="number">1</span>,a%=p;</span><br><span class="line"><span class="keyword">while</span>(b)&#123;</span><br><span class="line">  <span class="keyword">if</span>(b%<span class="number">2</span>==<span class="number">1</span>) ans=(ans*a)%p;</span><br><span class="line">  a=(a*a)%p;</span><br><span class="line">  b&gt;&gt;<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 简单算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>R.I.P. Avicii ◢ ◤</title>
      <link href="/2019/06/06/Avicii/"/>
      <url>/2019/06/06/Avicii/</url>
      
        <content type="html"><![CDATA[<p>2019.6.6北京时间23:00:00(当地时间17:00:00)，Avicii的遗作专辑<code>&lt;Tim&gt;</code>发布。希望这永远不是鸽王的最后一张专辑。</p><a id="more"></a><p>曲目列表：(12 songs)</p><ul><li>Peace Of Mind</li><li>Heaven</li><li>SOS</li><li>Tough Love</li><li>Bad Reputation</li><li>Ain’t A Thing</li><li>Hold The Line</li><li>Freak</li><li>Excuse Me Mr Sir</li><li>Heart Upon My Sleeve</li><li>Never Leave Me</li><li>Fades Away</li></ul><p>Rest in Peace.</p><p><img src="https://i.loli.net/2019/04/28/5cc5a73b9898d.jpeg" alt></p>]]></content>
      
      
      <categories>
          
          <category> 音乐 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> music </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P3056 笨牛 Clumsy Cows [题解]</title>
      <link href="/2019/03/03/P3056%20%E7%AC%A8%E7%89%9BClumsy%20Cows%20%E9%A2%98%E8%A7%A3/"/>
      <url>/2019/03/03/P3056%20%E7%AC%A8%E7%89%9BClumsy%20Cows%20%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P3056" target="_blank" rel="noopener">题目传送门</a></p><p>明显，这是一道用栈解决的<del>水</del>题。但是除了栈，还有另外一种简单一点的方法。</p><a id="more"></a><p>切入正题：</p><h1 id="1-栈-stack"><a href="#1-栈-stack" class="headerlink" title="1.栈(stack)"></a>1.栈(stack)</h1><p>运用<strong>STL</strong>中的<code>#include&lt;stack&gt;</code></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">stack</span>&lt;类型&gt; st;</span><br><span class="line">压栈 st.push(元素);</span><br><span class="line">出栈 st.pop();</span><br><span class="line">获取栈顶元素 st.top();</span><br><span class="line">栈的大小(元素个数) st.size();</span><br><span class="line">判断栈是否为空(栈空输出<span class="literal">true</span>，反之亦然) st.empty();</span><br></pre></td></tr></table></figure><h2 id="例：判断括号是否匹配"><a href="#例：判断括号是否匹配" class="headerlink" title="例：判断括号是否匹配"></a>例：判断括号是否匹配</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; st;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.size(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">'('</span>) st.push(s[i]); <span class="comment">//左括号进栈</span></span><br><span class="line">        <span class="keyword">else</span>&#123; <span class="comment">//不是左括号就是右括号</span></span><br><span class="line">            <span class="keyword">if</span>(st.empty()) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//如果当前栈空，莫名其妙来一个右括号即为不匹配</span></span><br><span class="line">            <span class="keyword">else</span> st.pop(); <span class="comment">//说明栈里有待匹配的左括号，弹出一个（配对成功）</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="上代码"><a href="#上代码" class="headerlink" title="上代码"></a>上代码</h2><p>真是喜闻乐见的一个环节呢</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; st;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.size(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">'('</span>) st.push(s[i]); <span class="comment">//左括号进栈</span></span><br><span class="line">        <span class="keyword">else</span>&#123; <span class="comment">//不是左括号就是右括号</span></span><br><span class="line">            <span class="keyword">if</span>(st.empty())&#123;st.push(<span class="string">'('</span>); ans++;&#125; <span class="comment">//注意。如果不匹配就说明需要括号反转，因此反转括号，ans++</span></span><br><span class="line">            <span class="keyword">else</span> st.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!st.empty()) ans+=st.size()/<span class="number">2</span>; <span class="comment">//如果剩下一堆左括号，说明需要反转一半的才能配对成功</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-加减计数法"><a href="#2-加减计数法" class="headerlink" title="2.加减计数法"></a>2.加减计数法</h1><p>和栈的原理差不多，只不过简单易懂，不用掌握栈。时间的话<del>让我们大声喊出：STL NB!</del></p><p>左括号+1，右括号-1。如果匹配的话就是0了。</p><p>当然也有反例：<code>())(</code>单纯判断最终结果是否为0会出错WA</p><p>因此，我们可以发现：如果当前为0(栈空)再加入一个右括号那就需要反转了</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>,p=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.size(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">'('</span>) p++; <span class="comment">//类似进栈</span></span><br><span class="line">        <span class="keyword">else</span>&#123; <span class="comment">//不是左括号就是右括号</span></span><br><span class="line">            <span class="keyword">if</span>(p) p--; <span class="comment">//有一个左括号等待配对，那就配对</span></span><br><span class="line">            <span class="keyword">else</span> ans++,p++; <span class="comment">//反转</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans+=p/<span class="number">2</span>; <span class="comment">//道理同栈</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结尾小声bb：<del>感觉题目背景尽是扯淡2333</del></p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线段树 浅析</title>
      <link href="/2019/02/24/%E7%BA%BF%E6%AE%B5%E6%A0%91%20%E6%B5%85%E6%9E%90/"/>
      <url>/2019/02/24/%E7%BA%BF%E6%AE%B5%E6%A0%91%20%E6%B5%85%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="线段树"><a href="#线段树" class="headerlink" title="线段树?"></a>线段树?</h1><p>线段树是一种二叉搜索树，与区间树相似，它将一个区间划分成一些单元区间，每个单元区间对应线段树中的一个叶结点。</p><p>使用线段树可以快速的查找某一个节点在若干条线段中出现的次数，时间复杂度为O(logN）。而未优化的空间复杂度为2N，因此有时需要离散化让空间压缩。</p><a id="more"></a><table><thead><tr><th style="text-align:left"></th><th>查询</th><th>修改</th></tr></thead><tbody><tr><td style="text-align:left">朴素算法</td><td><code>O(n)</code></td><td><code>O(1)</code></td></tr><tr><td style="text-align:left">前缀和</td><td><code>O(1)</code></td><td><code>O(n)</code></td></tr><tr><td style="text-align:left">树状数组</td><td><code>O(log2 n)</code></td><td><code>O(log2 n)</code></td></tr><tr><td style="text-align:left">ST表</td><td><code>O(1)</code></td><td><code>O(log2 n)</code></td></tr><tr><td style="text-align:left">线段树</td><td><code>O(1)</code></td><td><code>O(log2 n)</code></td></tr><tr><td style="text-align:left">单调队列</td><td><code>O(1)</code></td><td>或许不能修改</td></tr></tbody></table><h1 id="线段树模版1"><a href="#线段树模版1" class="headerlink" title="线段树模版1"></a>线段树模版1</h1><p><u> <strong>[区间最值，仅满足单点修改]</strong></u></p><p><strong>满足以下特性：</strong></p><blockquote><ol><li>树中每一个节点，代表一个区间</li><li>根节点代表一个完整的期间<code>[1,n]</code></li><li>每个叶子节点代表长度为1的区间<code>[x,x]</code>，即区间的一个元素</li><li>对于非叶子节点的每一个节点<code>[l,r]</code>，它的左儿子是<code>[l,mid]</code>，右儿子是<code>[mid+1,r]</code>。其中<code>mid=(l+r)/2</code></li><li>一个完整二叉树中，根节点p的左儿子编号为<code>p*2</code>，右儿子编号为<code>p*2+1</code>。</li></ol></blockquote><h2 id="Code-lt-gt"><a href="#Code-lt-gt" class="headerlink" title="Code&lt; / &gt;"></a>Code&lt; / &gt;</h2><ul><li>节点声明<strong>(区间: l , r)(状态值(最值): dat)</strong>：</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r,dat;</span><br><span class="line">&#125;t[<span class="number">4</span>*N];</span><br></pre></td></tr></table></figure><ul><li>建树<strong>(区间: l , r)(状态值(最值)dat)</strong>：</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> <span class="comment">//p为当前的节点编号,l r 是当前要赋给t[p]的l r</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    t[p].l=l,t[p].r=r;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;t[p].dat=a[l]; <span class="keyword">return</span>;&#125; <span class="comment">//递归到叶子节点，叶子节点的最值就是它本身</span></span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)/<span class="number">2</span>; <span class="comment">//对半剖分</span></span><br><span class="line">    build(p*<span class="number">2</span>,l,mid); <span class="comment">//左儿子</span></span><br><span class="line">    build(p*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r); <span class="comment">//右儿子</span></span><br><span class="line">    t[p].dat=max(t[p*<span class="number">2</span>].dat,t[p*<span class="number">2</span>+<span class="number">1</span>].dat); <span class="comment">//最值，可换min</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>询问某区间[l,r]的最值：</li></ul><blockquote><p>1.该节点全覆盖时不再往下递归，但需返回该节点的值</p><p>2.该节点取中点mid后,观察是那一边（中点左右）完全没有覆盖则不再往下递归;否则都需要往下递归（含半边全覆盖，因为下一层会直接返回值）</p><p>3.该节点需返回两边递归后处理的结果（当然，如果只有一边递归，就直接返回这一边的值）</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=t[p].l &amp;&amp; t[p].r&lt;=r) <span class="keyword">return</span> t[p].dat;</span><br><span class="line"><span class="keyword">int</span> mid=(t[p].l+t[p].r)/<span class="number">2</span>;</span><br><span class="line">  <span class="keyword">int</span> val=<span class="number">-999999999</span>; <span class="comment">//最值</span></span><br><span class="line">    <span class="keyword">if</span>(l&lt;=mid) val=max(val,ask(p*<span class="number">2</span>,l,r));</span><br><span class="line">    <span class="keyword">if</span>(r&gt;mid) val=max(val,ask(p*<span class="number">2</span>+<span class="number">1</span>,l,r));</span><br><span class="line">  <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>指定位置x ,修改值为v （递归过程同上）：</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> x,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t[p].l==t[p].r) &#123;t[p].dat=v; <span class="keyword">return</span>;&#125;</span><br><span class="line">  <span class="keyword">int</span> mid=(t[p].l+t[p].r)/<span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span>(x&lt;=mid) change(p*<span class="number">2</span>,x,v);</span><br><span class="line">    <span class="keyword">else</span> change(p*<span class="number">2</span>+<span class="number">1</span>,x,v);</span><br><span class="line">  t[p].dat=max(t[p*<span class="number">2</span>].dat,t[p*<span class="number">2</span>+<span class="number">1</span>].dat);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="线段树模版2"><a href="#线段树模版2" class="headerlink" title="线段树模版2"></a>线段树模版2</h1><p>[满足区间修改] <a href="https://www.luogu.org/problem/P3372" target="_blank" rel="noopener">P3372 【模板】线段树 1</a></p><p><strong>带延迟标记功能的线段树</strong></p><h2 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h2><ul><li>spread(int p)为延迟标记下移一层</li></ul><p><strong>注意：当该层打上标记后，表示该层内容已经修改，本层以下等待机会再修改。机会来之下一次修改或查询时经过此节点往下递归时。</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t[p].add&gt;<span class="number">0</span>)&#123;</span><br><span class="line">    t[<span class="number">2</span>*p].dat+=t[p].add*(t[<span class="number">2</span>*p].r-t[<span class="number">2</span>*p].l+<span class="number">1</span>);</span><br><span class="line">t[<span class="number">2</span>*p+<span class="number">1</span>].dat+=t[p].add*(t[<span class="number">2</span>*p+<span class="number">1</span>].r-t[<span class="number">2</span>*p+<span class="number">1</span>].l+<span class="number">1</span>);</span><br><span class="line">t[<span class="number">2</span>*p].add+=t[p].add;</span><br><span class="line">t[<span class="number">2</span>*p+<span class="number">1</span>].add+=t[p].add;</span><br><span class="line">t[p].add=<span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="推荐题"><a href="#推荐题" class="headerlink" title="推荐题"></a>推荐题</h1><p>来做题吧！</p><ul><li><a href="https://www.luogu.org/problem/P1531" target="_blank" rel="noopener">I Hate It</a></li><li><a href="https://www.luogu.org/problem/P1774" target="_blank" rel="noopener">最接近神的人</a></li><li><a href="https://www.luogu.org/problem/P1816" target="_blank" rel="noopener">忠诚</a></li><li><a href="https://www.luogu.org/problem/P2590" target="_blank" rel="noopener">树的统计</a></li><li><a href="https://www.luogu.org/problem/P2073" target="_blank" rel="noopener">送花</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RMQ问题&amp;ST表 浅析</title>
      <link href="/2019/02/15/RMQ%E9%97%AE%E9%A2%98&amp;ST%E8%A1%A8%20%E6%B5%85%E6%9E%90/"/>
      <url>/2019/02/15/RMQ%E9%97%AE%E9%A2%98&amp;ST%E8%A1%A8%20%E6%B5%85%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是RMQ问题？"><a href="#什么是RMQ问题？" class="headerlink" title="什么是RMQ问题？"></a>什么是RMQ问题？</h1><p>RMQ(Range Min/Max Query):</p><p>对于长度为n的数组A，回答若干询问<code>RMQ(A,i,j)(i,j&lt;=n-1)</code>返回数组A中下标在i,j范围内的最小（大）值，即<strong>RMQ问题是指求区间最值的问题</strong>。</p><p>解决方式：</p><ul><li>朴素算法：每查询一次为O(n)</li><li>ST算法：高效，以O(n log n)的预处理代价，换取O(1)的查询时性能</li></ul><a id="more"></a><h1 id="ST算法"><a href="#ST算法" class="headerlink" title="ST算法"></a>ST算法</h1><p>令：<strong>f[i,j]</strong>代表从第i个数起连续2^j个数中的最大值（因此要用倍增）</p><p>从下图可以看出：<code>f[0][1]=max(f[0][0],f[1][0]), …… f[[0][2]=max(f[0][1],f[2][1]) ……</code></p><p><img src="https://i.loli.net/2019/08/11/JVOWeI9r6CXdEom.png" alt="st表"></p><p> 采用动态规划的思想：显然<code>f[i,j]=max(f[i,j-1],f[i+2^(j-1),j-1])</code></p><p>所以，我们需要建立ST表，也就是上文中的f数组。生成ST表是一次预处理，此后都是O(1)的查询了。</p><h2 id="建立ST表"><a href="#建立ST表" class="headerlink" title="建立ST表"></a>建立ST表</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=n; i++) f[i][<span class="number">0</span>]=a[i]; <span class="comment">//初始化，第0列(j=0)就是a[i]。</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=<span class="number">20</span>; j++)  <span class="comment">//j&lt;20很大啦，够用！2^20=1048576</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i+(<span class="number">1</span>&lt;&lt;j)&lt;=n+<span class="number">1</span>; i++)</span><br><span class="line">f[i][j]=max(f[i][j<span class="number">-1</span>],f[i+(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))][j<span class="number">-1</span>]);</span><br></pre></td></tr></table></figure><p>查询时，只需取在ST表中找2段头尾满足区间范围进行拼凑，有重叠覆盖不影响结果。</p><p>Why?我们来模拟一下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">设A=2，6，4，8，4，8，4，8</span><br><span class="line">求RMQ(A,0,5)[MAX值]=max(RMQ(A,0,3),RMQ(A,2,5))，无论是直接求还是分两段重复的区间求的结果都是8</span><br><span class="line">因为不是运算，所以有重叠部分是可以的哦！</span><br></pre></td></tr></table></figure><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><p>设：范围是 [m,n] ,这个范围不会是刚好2 ^k的长度，我们就用2段区间来拼凑：</p><p>即<code>[m,m+2^k-1]</code>和<code>[n-2^k+1,n]</code> (拼凑后头尾满足[m,n],中间允许重叠)</p><p>因此查询结果即为：<code>RMQ[A,m,n]=max(f[m][k],f[n-(1&lt;&lt;k)+1][k]);</code></p><p>其中2^k&lt;=(n-m+1) 则 <code>k=log2(n-m+1);</code></p><p>举个例子：查询<code>RMQ[A,1,6]=max(f[1][2],f[3][2])</code></p><p><img src="http://t1.aixinxi.net/o_1d3oq2ihs1u8e11l5snpbs21mgoa.png-w.jpg" alt="ST表举例"></p><h3 id="log对数函数"><a href="#log对数函数" class="headerlink" title="log对数函数"></a>log对数函数</h3><p>这里的log来说一下，对数是对求幂的逆运算，正如除法是乘法的倒数</p><p>如果a^x =N（a&gt;0，且a≠1），那么数x叫做以a为底N的对数，记作x=loga N，读作以a为底N的对数，其中a叫做对数的底数，N叫做真数。</p><p>比如说2^5=32，log2 32=5，求的是n次方</p><h1 id="ST表例题"><a href="#ST表例题" class="headerlink" title="ST表例题"></a>ST表例题</h1><h2 id="【模板】ST表-Luogu"><a href="#【模板】ST表-Luogu" class="headerlink" title="【模板】ST表-Luogu"></a><a href="https://www.luogu.org/problemnew/show/P3865" target="_blank" rel="noopener">【模板】ST表-Luogu</a></h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">2000001</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,a[maxn],lg[maxn],f[maxn][<span class="number">25</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="comment">//读入&amp;预处理</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">        f[i][<span class="number">0</span>]=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=<span class="number">20</span>; j++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i+(<span class="number">1</span>&lt;&lt;j)&lt;=n+<span class="number">1</span>;i++)</span><br><span class="line">            f[i][j]=max(f[i][j<span class="number">-1</span>],f[i+(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))][j<span class="number">-1</span>]);</span><br><span class="line">    <span class="comment">//回答每个询问</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> l,r; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;l,&amp;r);</span><br><span class="line">        <span class="keyword">int</span> k=log2(r-l+<span class="number">1</span>),ans=max(f[l][k],f[r-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k]); <span class="comment">//直接使用cmath头文件里的`log2`函数</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="质量检测-Luogu"><a href="#质量检测-Luogu" class="headerlink" title="质量检测-Luogu"></a><a href="https://www.luogu.org/problemnew/show/P2251" target="_blank" rel="noopener">质量检测-Luogu</a></h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//裸的模版题，只不过是没有询问需要自己“手动添加”罢了</span></span><br><span class="line"><span class="comment">//还有一个点就是题目中求的是min值就要将原模版中的所有max改成min才能pass哦</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1000000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> f[N][<span class="number">25</span>],n,m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;f[i][<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>; k&lt;=<span class="number">20</span>; k++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    <span class="keyword">if</span>(i+(<span class="number">1</span>&lt;&lt;k)<span class="number">-1</span>&lt;=n) f[i][k]=min(f[i][k<span class="number">-1</span>],f[i+(<span class="number">1</span>&lt;&lt;(k<span class="number">-1</span>))][k<span class="number">-1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n-m+<span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> s=log2(m);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,min(f[i][s],f[i+m-(<span class="number">1</span>&lt;&lt;s)][s]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RMQ问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>优雅地使用Hexo搭建自己的静态博客3</title>
      <link href="/2019/01/22/%E4%BC%98%E9%9B%85%E5%9C%B0%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A23/"/>
      <url>/2019/01/22/%E4%BC%98%E9%9B%85%E5%9C%B0%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A23/</url>
      
        <content type="html"><![CDATA[<h1 id="关联GitHub账号！"><a href="#关联GitHub账号！" class="headerlink" title="关联GitHub账号！"></a>关联GitHub账号！</h1><p>看了之前的教程，你可能会有一个疑问：woc！输入密码真<del>jb</del>烦人！有没有什么方便的方法让我可以在提交时免密码登陆呢？</p><p>为了每一次部署不必一种输入密码，我们可以生成秘钥，然后提交到GitHub，进行关联，那么你下次就不需要再输入密码了。免密提交：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 用你注册GitHub时的邮箱号，进行秘钥生成</span></span><br><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">ssh-keygen -t rsa -C <span class="string">"xxxxxxx@qq.com"</span></span><br><span class="line"><span class="comment"># 系统就会生成一个隐藏文件夹.ssh</span></span><br><span class="line"><span class="built_in">cd</span> .ssh</span><br><span class="line">ls</span><br><span class="line"><span class="comment"># 复制公钥</span></span><br><span class="line">vim id_rsa.pub</span><br></pre></td></tr></table></figure><a id="more"></a><p>在公钥出现后复制下来，切记不要把公钥泄露。大概是这样的：<img src="http://t1.aixinxi.net/o_1d1qtbh4ls97up51h3mecaarda.png-w.jpg" alt="这个"></p><p>来到GitHub，点击头像，进入设置，然后点击SSH and GPG keys，创建新的SSH，将之前复制的公钥黏贴，提交，OK。</p><p><img src="https://upload-images.jianshu.io/upload_images/3478485-9a6fe8e8a47d59dc.png" alt="这个"></p><p><img src="https://upload-images.jianshu.io/upload_images/3478485-92b2d4a66901907b.png" alt="这个"></p><p><img src="https://upload-images.jianshu.io/upload_images/3478485-94a0d1a2f04727f6.png" alt="这个"></p><p>记得，点击的是SSH keys那一行的新建按钮。</p><h1 id="发布文章！"><a href="#发布文章！" class="headerlink" title="发布文章！"></a>发布文章！</h1><h2 id="创建新的文章"><a href="#创建新的文章" class="headerlink" title="创建新的文章"></a>创建新的文章</h2><p>终端进入blog文件夹，输入<code>hexo new 文章名称</code>。执行之后，就会在<code>~/blog/source/_posts/博客名称.md</code>里自动创建“博客名称”.md的markdown文件，然后你就可以输入内容。</p><h3 id="文章front-matter"><a href="#文章front-matter" class="headerlink" title="文章front-matter"></a>文章front-matter</h3><p>.md是markdown的文件后缀名。在第一篇有介绍过用什么软件可以打开它。之后，你可以看到typora打开的窗口中上方有一个框框，储存的是文章的各种元素。它叫Front-matter，是文件最上方以 <code>---</code> 分隔的区域，用于指定个别文件的变量，举例来说：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hello World</span><br><span class="line">date: 2013/7/13 20:46:25</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>在typora中显示的是一个框框，是因为其主题的设置（美化）。在普通编辑器中看到的就是上面这个样子。</p><p>以下是预先定义的参数，您可在模板中使用这些参数值并加以利用。这里选取一些常用的：</p><table><thead><tr><th>参数</th><th>描述</th><th>默认值</th></tr></thead><tbody><tr><td><code>layout</code></td><td>布局</td><td></td></tr><tr><td><code>title</code></td><td>标题</td><td></td></tr><tr><td><code>date</code></td><td>建立日期</td><td>文件建立日期</td></tr><tr><td><code>updated</code></td><td>更新日期</td><td>文件更新日期</td></tr><tr><td><code>comments</code></td><td>开启文章的评论功能</td><td>true</td></tr><tr><td><code>tags</code></td><td>标签（不适用于分页）</td><td></td></tr><tr><td><code>categories</code></td><td>分类（不适用于分页）</td></tr></tbody></table><h3 id="分类和标签"><a href="#分类和标签" class="headerlink" title="分类和标签"></a>分类和标签</h3><p>只有文章支持分类和标签，您可以在 Front-matter 中设置。在其他系统中，分类和标签听起来很接近，但是在 Hexo 中两者有着明显的差别：分类具有顺序性和层次性，也就是说 <code>Foo, Bar</code> 不等于 <code>Bar, Foo</code>；而标签没有顺序和层次。</p><h2 id="发布博文"><a href="#发布博文" class="headerlink" title="发布博文"></a>发布博文</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>然后去<code>username.github.io</code>查看，如果有你的博文在上面，那么就成功了！</p><h2 id="删除博文"><a href="#删除博文" class="headerlink" title="删除博文"></a>删除博文</h2><p>进入<code>~/blog/source/_posts</code>就可以看到你之前发的所有文章。直接删除文件并更新博客即可。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li><a href="https://www.jianshu.com/p/77db3862595c" target="_blank" rel="noopener">https://www.jianshu.com/p/77db3862595c</a></li></ul><p><em>欢迎提出意见！</em></p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>优雅地使用Hexo搭建自己的静态博客2</title>
      <link href="/2019/01/21/%E4%BC%98%E9%9B%85%E5%9C%B0%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A22/"/>
      <url>/2019/01/21/%E4%BC%98%E9%9B%85%E5%9C%B0%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A22/</url>
      
        <content type="html"><![CDATA[<h1 id="继续！"><a href="#继续！" class="headerlink" title="继续！"></a>继续！</h1><p>既然我们已经完成了Hexo的安装，那么就是开始使用了。请确保以下步骤在你正确安装完Hexo之后进行。</p><a id="more"></a><h3 id="创建一个blog文件夹"><a href="#创建一个blog文件夹" class="headerlink" title="创建一个blog文件夹"></a>创建一个blog文件夹</h3><p>打开终端，输入<code>mkdir blog</code>。这里的blog可以是你想要的名字，这个文件夹将会作为你今后的Hexo博客的根目录。你的主题设置、博客文章等都会保存在这里。</p><p>使用<code>cd blog</code>进入目录。记住这个代码，这将是你以后的常用指令（在你执行Hexo来更新、部署你的博客时，<em>需要进入你的博客文件夹操作</em>，否则会报错）。</p><h3 id="开启本地服务"><a href="#开启本地服务" class="headerlink" title="开启本地服务"></a>开启本地服务</h3><p>既然配置完了Hexo，我们就可以开启本地服务了。进入文件夹，输入<code>hexo s</code>开启本地服务。接下来，你可以看到<img src="http://t1.aixinxi.net/o_1d1nvmghl1u7510cua0mtto7ria.png-w.jpg" alt="这个"></p><p>把网址复制下来，输入到浏览器里打开，就可以看到类似于这样子的界面：<img src="https://upload-images.jianshu.io/upload_images/3478485-7c18ba82bb6dd688.png" alt="这个"></p><p>到这里说明你的环境以及没有问题了，成功了搭建起了博客框架。</p><p>注：<code>hexo s</code>这个命令其实挺有用的，可以看到编辑后博客的样子（不是网页！别人如果登陆这个本地网址也看不到你的博客），但用时比发布时间短，可以快速知道blog的样子。</p><h1 id="GitHub-Page关联"><a href="#GitHub-Page关联" class="headerlink" title="GitHub Page关联"></a>GitHub Page关联</h1><p><a href="https://baike.baidu.com/item/github/10145341?fr=aladdin" target="_blank" rel="noopener">GitHub简介</a>，就是一个代码托管平台。有个功能叫做GitHub Page，用于静态页面的项目托管，Hexo博客一般会先选择将它托管在这里。先来注册一下：<a href="https://github.com/" target="_blank" rel="noopener">GitHub官网</a>。可以看到这样：<img src="http://t1.aixinxi.net/o_1d1o0umlo7104n55qv143o1dpfa.png-w.jpg" alt="这个"></p><p>输入username，注意一下，这里的名字将关联到你博客网址（GitHub版）的名称，慎重！<u>我原来把residual打错了于是又折腾了一个23333！</u>第二行输入邮箱、第三行输入密码。密码只输一次，小心一点。</p><h3 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h3><p>由于GitHub网站是纯英文的，没有翻译有些人可能看得难受。在这里推荐使用Chrome谷歌浏览器。它在浏览纯英文网页时会有一个网页翻译的功能，方便理解。<img src="http://t1.aixinxi.net/o_1d1o34b8e1ctu1upi13eldpa1l6ba.png-w.jpg" alt="这个"></p><h2 id="建立仓库"><a href="#建立仓库" class="headerlink" title="建立仓库"></a>建立仓库</h2><p>注册完后显示的界面就是你的仪表盘。右上角找到新建图标，点击<em>New repository</em>，如图：<img src="https://upload-images.jianshu.io/upload_images/3478485-918befac816ff5d6.png" alt="这个"></p><p>跳出该界面：<img src="https://upload-images.jianshu.io/upload_images/3478485-d451ae9bb81c6d0e.png" alt="这个"></p><blockquote><p> 这里的owner就是你当前的用户名。创建仓库的名字必须为<code>username.github.io</code>（就是那个name的输入框里填写的内容），我的用户名为ResidualNight，因此我创建的仓库名就是<strong>ResidualNight.github.io</strong>，这是很关键的一点，很重要。输入名字后，直接点最下面绿色的按钮，创建新仓库。<strong>切记用户名的正确与否</strong>！</p></blockquote><h2 id="关联博客"><a href="#关联博客" class="headerlink" title="关联博客"></a>关联博客</h2><p>打开blog根目录。这里有一个文件叫做”_config.yml”，打开。如果有好的编辑器可以用，如：visual studio code等，正常情况下直接用文本编辑可以打开。<img src="http://t1.aixinxi.net/o_1d1o3mcc21oji1boei4uq2n1p5na.png-w.jpg" alt="这个"></p><p>找到如图所示的代码段，输入和我一样的内容。至于我的ResidualNight，替换成你自己的GitHub用户名。然后保存文件。</p><p>回到终端进入目录，输入命令（“#”为注释内容，不用输）：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 产生静态网页</span></span><br><span class="line">hexo g</span><br><span class="line"><span class="comment"># 部署到GitHub page上</span></span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>以后，我们在更新文章、主题设置时都会运用到这两个命令，注意顺序，先g后d。在<code>hexo d</code>后，会要求输入GitHub的账户名称和密码。</p><p><code>hexo g</code>正常：<img src="http://t1.aixinxi.net/o_1d1o9q97r1a5dtue1p8u1m971878a.png-w.jpg" alt="hexo g"></p><p><code>hexo d</code>输入用户名&amp;密码图示：<img src="http://t1.aixinxi.net/o_1d1o9udq0ih9eai1jf01s2j99ia.png-w.jpg" alt="hexo d">这里注意一下，输入密码时一般是不显示你的密码的。</p><p>部署完了网页，就可以登陆网页了！浏览器输入username.github.io，就可以看到你的博客了。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li><a href="https://www.jianshu.com/p/77db3862595c" target="_blank" rel="noopener">https://www.jianshu.com/p/77db3862595c</a></li><li>想知道根目录文件夹里的文件做什么的看这里：<a href="https://hexo.io/zh-cn/docs/setup" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/setup</a></li></ul><p><em>欢迎提出意见！</em></p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>优雅地使用Hexo搭建自己的静态博客1</title>
      <link href="/2019/01/20/%E4%BC%98%E9%9B%85%E5%9C%B0%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A21/"/>
      <url>/2019/01/20/%E4%BC%98%E9%9B%85%E5%9C%B0%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A21/</url>
      
        <content type="html"><![CDATA[<h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><p>如题，这个静态博客就是使用hexo制作的。如果你对此有兴趣，有探究精神（<del>又闲着没有事</del>），那么你可以来尝试制作一下你的blog！在这里，我会尽量用通俗一些的语言来阐述这一过程，那么我们开始吧！</p><p>如果你是一个大佬，这一章的内容自行跳过。<del>是大佬也不会来看我的博客了233</del></p><a id="more"></a><p>这里开始科普一下我们所需要的东西：</p><h2 id="Hexo是个什么玩意儿？"><a href="#Hexo是个什么玩意儿？" class="headerlink" title="Hexo是个什么玩意儿？"></a>Hexo是个什么玩意儿？</h2><p>看到标题，你可能会有些蒙圈：hexo是个什么鬼？这个很简单，你可以请教一下baidu以及<a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">官网</a>。稍稍引用一下：</p><blockquote><p>hexo 正常来说，不需要部署到我们的服务器上。我们的服务器上保存的，其实是基于在hexo通过<u>markdown</u>编写的文章，然后hexo帮我们生成静态的html页面，然后，将生成的html上传到我们的服务器，这样就有了我们所看到的博客界面。简而言之：hexo是个<em>静态页面生成、上传的工具</em>。</p></blockquote><p>简单来说，就是配置好了hexo后，你只用写出博客网站的<u>markdown</u>代码（保存在一定的地方），就可以让hexo帮助你制作出含有你的博文的网页。当然你也可以自己定制网页的自定义，比如说下载他人的主题，并按自己的想法进行改进。</p><p>许多大佬、或是萌新们都会使用hexo搭建blog，毕竟人家简单、自由度还高嘛。</p><h2 id="Markdown又是个什么玩意儿？"><a href="#Markdown又是个什么玩意儿？" class="headerlink" title="Markdown又是个什么玩意儿？"></a>Markdown又是个什么玩意儿？</h2><p>这个真的就只有baidu可以帮助你了：<a href="https://baike.baidu.com/item/markdown/3245829?fr=aladdin" target="_blank" rel="noopener">Markdown强行科普</a>。其实就是在正常打字时加上一些特殊的符号让文章能够层次分明，是一种在博客、OI（编程界）里十分流行的文本语言，hexo用的就是这种流行的语言。至于具体用法，在上文的链接中有说明，如果可以，我会放到“文章”那一部分那里写～</p><p>这里比较推荐的markdown书写工具是这个：<a href="https://www.typora.io/" target="_blank" rel="noopener">typora</a>，简洁好用，支持hexo格式。</p><h2 id="‘终端’科普"><a href="#‘终端’科普" class="headerlink" title="‘终端’科普"></a>‘终端’科普</h2><p>现在有两个主流电脑操作系统：</p><ul><li>mac</li><li>windows</li></ul><p>Mac的终端名称是终端（Terminal），打开它很简单，进入启动台查找或是使用聚焦搜索查找；</p><p>Windows的终端名称一般叫做cmd，在“开始”菜单栏里找到它或是使用“运行”这个应用输入cmd（实在不会的找baidu）</p><p>打开了吗？就是你眼前这个黑黑的东西，最上方有一串白字，代表你当前的启动盘。具体怎么用等会说。</p><h1 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h1><p>参考官网<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">文档</a>：</p><h2 id="安装Hexo的支持"><a href="#安装Hexo的支持" class="headerlink" title="安装Hexo的支持"></a>安装Hexo的支持</h2><p>Hexo的安装需要两个软件的支持，它们分别是：</p><ul><li><a href="http://nodejs.org/" target="_blank" rel="noopener">Node.js</a></li><li><a href="http://git-scm.com/" target="_blank" rel="noopener">Git</a></li></ul><h3 id="git安装"><a href="#git安装" class="headerlink" title="git安装"></a>git安装</h3><p>windows：下载并安装 <a href="https://git-scm.com/download/win" target="_blank" rel="noopener">git</a>（嫌下载速度慢的看这个<a href="https://github.com/waylau/git-for-win" target="_blank" rel="noopener">git国内下载站</a>注意看清楚版本号和windows版本，看不懂还是使用龟速下载比较好）</p><p>mac：在终端输入<code>brew install git</code>或下载 <a href="http://sourceforge.net/projects/git-osx-installer/" target="_blank" rel="noopener">安装程序</a> 安装。</p><h3 id="Node-js安装"><a href="#Node-js安装" class="headerlink" title="Node.js安装"></a>Node.js安装</h3><p>在这里用命令行安装可能讲的不太清楚。<a href="https://nodejs.org/en/" target="_blank" rel="noopener">下载地址</a>，下载安装。</p><p>对于Windows用户的建议：可以使用<strong>Git Bash</strong>，这是git for windows自带的一组程序，提供了Linux风格的shell。打开它的方法很简单，在<strong>桌面任意位置单击右键</strong>，选择“Git Bash Here”即可。由于Hexo的<strong>很多操作都涉及到命令行</strong>，您可以考虑始终使用<strong>Git Bash</strong>来进行操作。</p><h2 id="安装Hexo！"><a href="#安装Hexo！" class="headerlink" title="安装Hexo！"></a>安装Hexo！</h2><p>在完成上述安装后，安装hexo：</p><p>在终端里输入：<code>npm install -g hexo-cli</code></p><p>mac用户可能会报错。这里使用<code>sudo npm install -g hexo-cli</code>安装。</p><h1 id="一些建议"><a href="#一些建议" class="headerlink" title="一些建议"></a>一些建议</h1><ul><li>Windows中：终端中<code>Ctrl + C</code>是stop的快捷键，不要使用<code>Ctrl + C</code>或<code>Ctrl + V</code>的快捷键，用右键单击标题栏。</li><li>出现问题找官网和百度</li><li>也可以去找一些其他人写的教程，我写的是通俗版的，但归根到底都是根据别人的教程<del>不然我怎么搭建的博客233</del></li><li>哦对官网上也有b站的视频可以学习：<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/</a></li></ul><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li><a href="https://www.jianshu.com/p/77db3862595c" target="_blank" rel="noopener">https://www.jianshu.com/p/77db3862595c</a></li><li><a href="https://www.jianshu.com/p/a2fe56d11c4f" target="_blank" rel="noopener">https://www.jianshu.com/p/a2fe56d11c4f</a></li><li><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/</a></li></ul><p><em>欢迎提出意见！</em></p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Welcome</title>
      <link href="/2019/01/18/Welcome/"/>
      <url>/2019/01/18/Welcome/</url>
      
        <content type="html"><![CDATA[<h1 id="Hello"><a href="#Hello" class="headerlink" title="Hello!"></a>Hello!</h1><p><strong>很高兴认识你！</strong></p><p>这里是<em>Residual Night</em>的第一个个人博客，基于<a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo</a>&amp;&amp;<a href="https://github.com/" target="_blank" rel="noopener">github</a>搭建的静态博客。以<a href="https://xaoxuu.com/wiki/material-x/" target="_blank" rel="noopener">Material X</a>为主题。</p><a id="more"></a><h1 id="这是什么？"><a href="#这是什么？" class="headerlink" title="这是什么？"></a>这是什么？</h1><p>在这个blog上，主要会发表一些我的一些idea和编程笔记。至于编程，我只是一个刚接触<strong>c++</strong>的普及组+选手而已（初中苣蒻，勿喷）。但我坚信，我会在OI的道路上砥砺前行的。</p><h1 id="长风破浪会有时，直挂云帆济沧海。"><a href="#长风破浪会有时，直挂云帆济沧海。" class="headerlink" title="长风破浪会有时，直挂云帆济沧海。"></a>长风破浪会有时，直挂云帆济沧海。</h1><p>不管有没有人看得到，不管我会不会在这个博客上坚持下去，但这里总是一个梦想开始的地方。</p><h1 id="test"><a href="#test" class="headerlink" title="test"></a>test</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ios::sync_with_stdio();</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Hello World!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 个人生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> personal </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
